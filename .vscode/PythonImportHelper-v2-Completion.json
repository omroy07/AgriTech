[
    {
        "label": "streamlit",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "streamlit",
        "description": "streamlit",
        "detail": "streamlit",
        "documentation": {}
    },
    {
        "label": "google.generativeai",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "google.generativeai",
        "description": "google.generativeai",
        "detail": "google.generativeai",
        "documentation": {}
    },
    {
        "label": "speech_recognition",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "speech_recognition",
        "description": "speech_recognition",
        "detail": "speech_recognition",
        "documentation": {}
    },
    {
        "label": "GoogleTranslator",
        "importPath": "deep_translator",
        "description": "deep_translator",
        "isExtraImport": true,
        "detail": "deep_translator",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "send_file",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "redirect",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "send_from_directory",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "SocketIO",
        "importPath": "flask_socketio",
        "description": "flask_socketio",
        "isExtraImport": true,
        "detail": "flask_socketio",
        "documentation": {}
    },
    {
        "label": "join_room",
        "importPath": "flask_socketio",
        "description": "flask_socketio",
        "isExtraImport": true,
        "detail": "flask_socketio",
        "documentation": {}
    },
    {
        "label": "leave_room",
        "importPath": "flask_socketio",
        "description": "flask_socketio",
        "isExtraImport": true,
        "detail": "flask_socketio",
        "documentation": {}
    },
    {
        "label": "send",
        "importPath": "flask_socketio",
        "description": "flask_socketio",
        "isExtraImport": true,
        "detail": "flask_socketio",
        "documentation": {}
    },
    {
        "label": "emit",
        "importPath": "flask_socketio",
        "description": "flask_socketio",
        "isExtraImport": true,
        "detail": "flask_socketio",
        "documentation": {}
    },
    {
        "label": "token_required",
        "importPath": "auth_utils",
        "description": "auth_utils",
        "isExtraImport": true,
        "detail": "auth_utils",
        "documentation": {}
    },
    {
        "label": "roles_required",
        "importPath": "auth_utils",
        "description": "auth_utils",
        "isExtraImport": true,
        "detail": "auth_utils",
        "documentation": {}
    },
    {
        "label": "token_required",
        "importPath": "auth_utils",
        "description": "auth_utils",
        "isExtraImport": true,
        "detail": "auth_utils",
        "documentation": {}
    },
    {
        "label": "roles_required",
        "importPath": "auth_utils",
        "description": "auth_utils",
        "isExtraImport": true,
        "detail": "auth_utils",
        "documentation": {}
    },
    {
        "label": "token_required",
        "importPath": "auth_utils",
        "description": "auth_utils",
        "isExtraImport": true,
        "detail": "auth_utils",
        "documentation": {}
    },
    {
        "label": "roles_required",
        "importPath": "auth_utils",
        "description": "auth_utils",
        "isExtraImport": true,
        "detail": "auth_utils",
        "documentation": {}
    },
    {
        "label": "token_required",
        "importPath": "auth_utils",
        "description": "auth_utils",
        "isExtraImport": true,
        "detail": "auth_utils",
        "documentation": {}
    },
    {
        "label": "roles_required",
        "importPath": "auth_utils",
        "description": "auth_utils",
        "isExtraImport": true,
        "detail": "auth_utils",
        "documentation": {}
    },
    {
        "label": "joblib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "joblib",
        "description": "joblib",
        "detail": "joblib",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "A4",
        "importPath": "reportlab.lib.pagesizes",
        "description": "reportlab.lib.pagesizes",
        "isExtraImport": true,
        "detail": "reportlab.lib.pagesizes",
        "documentation": {}
    },
    {
        "label": "canvas",
        "importPath": "reportlab.pdfgen",
        "description": "reportlab.pdfgen",
        "isExtraImport": true,
        "detail": "reportlab.pdfgen",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "RandomForestClassifier",
        "importPath": "sklearn.ensemble",
        "description": "sklearn.ensemble",
        "isExtraImport": true,
        "detail": "sklearn.ensemble",
        "documentation": {}
    },
    {
        "label": "RandomForestRegressor",
        "importPath": "sklearn.ensemble",
        "description": "sklearn.ensemble",
        "isExtraImport": true,
        "detail": "sklearn.ensemble",
        "documentation": {}
    },
    {
        "label": "RandomForestClassifier",
        "importPath": "sklearn.ensemble",
        "description": "sklearn.ensemble",
        "isExtraImport": true,
        "detail": "sklearn.ensemble",
        "documentation": {}
    },
    {
        "label": "LabelEncoder",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "LabelEncoder",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "LabelEncoder",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "train_test_split",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "train_test_split",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "GridSearchCV",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "mean_squared_error",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "r2_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "accuracy_score",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "CORS",
        "importPath": "flask_cors",
        "description": "flask_cors",
        "isExtraImport": true,
        "detail": "flask_cors",
        "documentation": {}
    },
    {
        "label": "CORS",
        "importPath": "flask_cors",
        "description": "flask_cors",
        "isExtraImport": true,
        "detail": "flask_cors",
        "documentation": {}
    },
    {
        "label": "CORS",
        "importPath": "flask_cors",
        "description": "flask_cors",
        "isExtraImport": true,
        "detail": "flask_cors",
        "documentation": {}
    },
    {
        "label": "CORS",
        "importPath": "flask_cors",
        "description": "flask_cors",
        "isExtraImport": true,
        "detail": "flask_cors",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "load_keras_model",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "predict_image_keras",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "encode_features",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "soil_encoder",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "crop_encoder",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "fertilizer_encoder",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "plot_training_history",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "secure_filename",
        "importPath": "werkzeug.utils",
        "description": "werkzeug.utils",
        "isExtraImport": true,
        "detail": "werkzeug.utils",
        "documentation": {}
    },
    {
        "label": "torch.nn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.nn",
        "description": "torch.nn",
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "load_model",
        "importPath": "tensorflow.keras.models",
        "description": "tensorflow.keras.models",
        "isExtraImport": true,
        "detail": "tensorflow.keras.models",
        "documentation": {}
    },
    {
        "label": "Sequential",
        "importPath": "tensorflow.keras.models",
        "description": "tensorflow.keras.models",
        "isExtraImport": true,
        "detail": "tensorflow.keras.models",
        "documentation": {}
    },
    {
        "label": "load_model",
        "importPath": "tensorflow.keras.models",
        "description": "tensorflow.keras.models",
        "isExtraImport": true,
        "detail": "tensorflow.keras.models",
        "documentation": {}
    },
    {
        "label": "image",
        "importPath": "tensorflow.keras.preprocessing",
        "description": "tensorflow.keras.preprocessing",
        "isExtraImport": true,
        "detail": "tensorflow.keras.preprocessing",
        "documentation": {}
    },
    {
        "label": "image",
        "importPath": "tensorflow.keras.preprocessing",
        "description": "tensorflow.keras.preprocessing",
        "isExtraImport": true,
        "detail": "tensorflow.keras.preprocessing",
        "documentation": {}
    },
    {
        "label": "predict_fertilizer",
        "importPath": "model",
        "description": "model",
        "isExtraImport": true,
        "detail": "model",
        "documentation": {}
    },
    {
        "label": "build_cnn_model",
        "importPath": "model",
        "description": "model",
        "isExtraImport": true,
        "detail": "model",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "ImageDataGenerator",
        "importPath": "tensorflow.keras.preprocessing.image",
        "description": "tensorflow.keras.preprocessing.image",
        "isExtraImport": true,
        "detail": "tensorflow.keras.preprocessing.image",
        "documentation": {}
    },
    {
        "label": "Conv2D",
        "importPath": "tensorflow.keras.layers",
        "description": "tensorflow.keras.layers",
        "isExtraImport": true,
        "detail": "tensorflow.keras.layers",
        "documentation": {}
    },
    {
        "label": "MaxPooling2D",
        "importPath": "tensorflow.keras.layers",
        "description": "tensorflow.keras.layers",
        "isExtraImport": true,
        "detail": "tensorflow.keras.layers",
        "documentation": {}
    },
    {
        "label": "Flatten",
        "importPath": "tensorflow.keras.layers",
        "description": "tensorflow.keras.layers",
        "isExtraImport": true,
        "detail": "tensorflow.keras.layers",
        "documentation": {}
    },
    {
        "label": "Dense",
        "importPath": "tensorflow.keras.layers",
        "description": "tensorflow.keras.layers",
        "isExtraImport": true,
        "detail": "tensorflow.keras.layers",
        "documentation": {}
    },
    {
        "label": "Dropout",
        "importPath": "tensorflow.keras.layers",
        "description": "tensorflow.keras.layers",
        "isExtraImport": true,
        "detail": "tensorflow.keras.layers",
        "documentation": {}
    },
    {
        "label": "CategoricalCrossentropy",
        "importPath": "tensorflow.keras.losses",
        "description": "tensorflow.keras.losses",
        "isExtraImport": true,
        "detail": "tensorflow.keras.losses",
        "documentation": {}
    },
    {
        "label": "get_data_generators",
        "importPath": "data_loader",
        "description": "data_loader",
        "isExtraImport": true,
        "detail": "data_loader",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "app",
        "importPath": "Crop_Planning.app",
        "description": "Crop_Planning.app",
        "isExtraImport": true,
        "detail": "Crop_Planning.app",
        "documentation": {}
    },
    {
        "label": "genai",
        "importPath": "google",
        "description": "google",
        "isExtraImport": true,
        "detail": "google",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "jwt",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "jwt",
        "description": "jwt",
        "detail": "jwt",
        "documentation": {}
    },
    {
        "label": "bcrypt",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "bcrypt",
        "description": "bcrypt",
        "detail": "bcrypt",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "uuid",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "uuid",
        "description": "uuid",
        "detail": "uuid",
        "documentation": {}
    },
    {
        "label": "validate_email",
        "importPath": "email_validator",
        "description": "email_validator",
        "isExtraImport": true,
        "detail": "email_validator",
        "documentation": {}
    },
    {
        "label": "EmailNotValidError",
        "importPath": "email_validator",
        "description": "email_validator",
        "isExtraImport": true,
        "detail": "email_validator",
        "documentation": {}
    },
    {
        "label": "translate_text",
        "kind": 2,
        "importPath": "AgriBot_folder.AgriBot",
        "description": "AgriBot_folder.AgriBot",
        "peekOfCode": "def translate_text(text, lang_code):\n    if lang_code == \"en\":\n        return text\n    try:\n        return GoogleTranslator(source=\"auto\", target=lang_code).translate(text)\n    except Exception as e:\n        return f\"Translation error: {e}\"\n# --- Gemini Response ---\ndef generate_response(user_query):\n    prompt = f\"\"\"",
        "detail": "AgriBot_folder.AgriBot",
        "documentation": {}
    },
    {
        "label": "generate_response",
        "kind": 2,
        "importPath": "AgriBot_folder.AgriBot",
        "description": "AgriBot_folder.AgriBot",
        "peekOfCode": "def generate_response(user_query):\n    prompt = f\"\"\"\nYou are AgriBot, an expert AI assistant in agriculture.\nAnswer the following question clearly and simply.\nQuestion: {user_query}\nRespond with helpful advice for Indian farmers. Mention crops, weather, soil, fertilizers, diseases, and best practices as needed.\n\"\"\"\n    response = model.generate_content(prompt)\n    return response.text.strip()\n# --- Voice Input ---",
        "detail": "AgriBot_folder.AgriBot",
        "documentation": {}
    },
    {
        "label": "recognize_speech",
        "kind": 2,
        "importPath": "AgriBot_folder.AgriBot",
        "description": "AgriBot_folder.AgriBot",
        "peekOfCode": "def recognize_speech():\n    recognizer = sr.Recognizer()\n    mic = sr.Microphone()\n    with mic as source:\n        st.info(\"üé§ Listening... Speak now\")\n        recognizer.adjust_for_ambient_noise(source)\n        audio = recognizer.listen(source)\n    try:\n        return recognizer.recognize_google(audio)\n    except sr.UnknownValueError:",
        "detail": "AgriBot_folder.AgriBot",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "AgriBot_folder.AgriBot",
        "description": "AgriBot_folder.AgriBot",
        "peekOfCode": "model = genai.GenerativeModel(\"gemini-1.5-flash\")\n# --- Streamlit Page Config ---\nst.set_page_config(page_title=\"üåæ AgriBot\", page_icon=\"üå±\", layout=\"centered\")\nst.markdown(\"<h1 style='text-align: center;'>üåæ AgriBot ‚Äì AI Agriculture Assistant</h1>\", unsafe_allow_html=True)\nst.markdown(\"<p style='text-align: center;'>Ask me about crops, soil, fertilizers, diseases & more!</p>\", unsafe_allow_html=True)\n# --- Custom CSS for Chat Bubbles ---\nst.markdown(\"\"\"\n    <style>\n    .chat-bubble {\n        padding: 12px 15px;",
        "detail": "AgriBot_folder.AgriBot",
        "documentation": {}
    },
    {
        "label": "language_map",
        "kind": 5,
        "importPath": "AgriBot_folder.AgriBot",
        "description": "AgriBot_folder.AgriBot",
        "peekOfCode": "language_map = {\n    \"English\": \"en\",\n    \"Hindi (‡§π‡§ø‡§Ç‡§¶‡•Ä)\": \"hi\",\n    \"Punjabi (‡®™‡©∞‡®ú‡®æ‡®¨‡©Ä)\": \"pa\"\n}\nselected_language = st.selectbox(\"üåê Choose Reply Language\", list(language_map.keys()), index=0)\ntarget_lang = language_map[selected_language]\n# --- Translate Output ---\ndef translate_text(text, lang_code):\n    if lang_code == \"en\":",
        "detail": "AgriBot_folder.AgriBot",
        "documentation": {}
    },
    {
        "label": "selected_language",
        "kind": 5,
        "importPath": "AgriBot_folder.AgriBot",
        "description": "AgriBot_folder.AgriBot",
        "peekOfCode": "selected_language = st.selectbox(\"üåê Choose Reply Language\", list(language_map.keys()), index=0)\ntarget_lang = language_map[selected_language]\n# --- Translate Output ---\ndef translate_text(text, lang_code):\n    if lang_code == \"en\":\n        return text\n    try:\n        return GoogleTranslator(source=\"auto\", target=lang_code).translate(text)\n    except Exception as e:\n        return f\"Translation error: {e}\"",
        "detail": "AgriBot_folder.AgriBot",
        "documentation": {}
    },
    {
        "label": "target_lang",
        "kind": 5,
        "importPath": "AgriBot_folder.AgriBot",
        "description": "AgriBot_folder.AgriBot",
        "peekOfCode": "target_lang = language_map[selected_language]\n# --- Translate Output ---\ndef translate_text(text, lang_code):\n    if lang_code == \"en\":\n        return text\n    try:\n        return GoogleTranslator(source=\"auto\", target=lang_code).translate(text)\n    except Exception as e:\n        return f\"Translation error: {e}\"\n# --- Gemini Response ---",
        "detail": "AgriBot_folder.AgriBot",
        "documentation": {}
    },
    {
        "label": "index",
        "kind": 2,
        "importPath": "Community.app",
        "description": "Community.app",
        "peekOfCode": "def index():\n    return render_template('index.html')\n@app.route(\"/communities\", methods=['GET'])\n@token_required\ndef get_communities():\n    return jsonify(list(communities.keys()))\n@app.route(\"/add_community\", methods=['POST'])\n@token_required\n@roles_required('admin')\ndef add_community():",
        "detail": "Community.app",
        "documentation": {}
    },
    {
        "label": "get_communities",
        "kind": 2,
        "importPath": "Community.app",
        "description": "Community.app",
        "peekOfCode": "def get_communities():\n    return jsonify(list(communities.keys()))\n@app.route(\"/add_community\", methods=['POST'])\n@token_required\n@roles_required('admin')\ndef add_community():\n    room = request.json.get('room')\n    if room and room not in communities:\n        communities[room] = set()\n        return jsonify({\"success\": True, \"communities\": list(communities.keys())})",
        "detail": "Community.app",
        "documentation": {}
    },
    {
        "label": "add_community",
        "kind": 2,
        "importPath": "Community.app",
        "description": "Community.app",
        "peekOfCode": "def add_community():\n    room = request.json.get('room')\n    if room and room not in communities:\n        communities[room] = set()\n        return jsonify({\"success\": True, \"communities\": list(communities.keys())})\n    return jsonify({\"success\": False, \"communities\": list(communities.keys())})\n@app.route(\"/delete_community\", methods=['POST'])\n@token_required\n@roles_required('admin')\ndef delete_community():",
        "detail": "Community.app",
        "documentation": {}
    },
    {
        "label": "delete_community",
        "kind": 2,
        "importPath": "Community.app",
        "description": "Community.app",
        "peekOfCode": "def delete_community():\n    room = request.json.get('room')\n    if room in communities and len(communities[room]) == 0:\n        del communities[room]\n        return jsonify({\"success\": True, \"communities\": list(communities.keys())})\n    return jsonify({\"success\": False, \"error\": \"Room not empty or doesn't exist\", \"communities\": list(communities.keys())})\n@socketio.on('join')\ndef on_join(data):\n    username = data.get('username')\n    room = data.get('room')",
        "detail": "Community.app",
        "documentation": {}
    },
    {
        "label": "on_join",
        "kind": 2,
        "importPath": "Community.app",
        "description": "Community.app",
        "peekOfCode": "def on_join(data):\n    username = data.get('username')\n    room = data.get('room')\n    if not username or not room:\n        emit('error', {'msg': 'Username and Room are required.'})\n        return\n    if room not in communities:\n        emit('error', {'msg': 'Room does not exist.'})\n        return \n    join_room(room)",
        "detail": "Community.app",
        "documentation": {}
    },
    {
        "label": "on_leave",
        "kind": 2,
        "importPath": "Community.app",
        "description": "Community.app",
        "peekOfCode": "def on_leave(data):\n    username = data['username']\n    room = data['room']\n    leave_room(room)\n    if room in communities and username in communities[room]:\n        communities[room].remove(username)\n        send({'msg': f'{username} left {room}'}, room=room)\n        emit('user_list', list(communities[room]), room=room)\n@socketio.on('message')\ndef handle_message(data):",
        "detail": "Community.app",
        "documentation": {}
    },
    {
        "label": "handle_message",
        "kind": 2,
        "importPath": "Community.app",
        "description": "Community.app",
        "peekOfCode": "def handle_message(data):\n    room = data['room']\n    username = data['username']\n    msg = data['msg']\n    from datetime import datetime\n    timestamp = datetime.now().strftime('%H:%M')\n    send({'msg': f'[{timestamp}] {username}: {msg}'}, room=room)\nif __name__ == '__main__':\n    socketio.run(app, debug=True)",
        "detail": "Community.app",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "Community.app",
        "description": "Community.app",
        "peekOfCode": "app = Flask(__name__)\napp.config['SECRET_KEY'] = 'secretkey'\nsocketio = SocketIO(app, cors_allowed_origins=\"*\")\n# room_name: set(usernames)\ncommunities = {}\n@app.route(\"/\")\ndef index():\n    return render_template('index.html')\n@app.route(\"/communities\", methods=['GET'])\n@token_required",
        "detail": "Community.app",
        "documentation": {}
    },
    {
        "label": "app.config['SECRET_KEY']",
        "kind": 5,
        "importPath": "Community.app",
        "description": "Community.app",
        "peekOfCode": "app.config['SECRET_KEY'] = 'secretkey'\nsocketio = SocketIO(app, cors_allowed_origins=\"*\")\n# room_name: set(usernames)\ncommunities = {}\n@app.route(\"/\")\ndef index():\n    return render_template('index.html')\n@app.route(\"/communities\", methods=['GET'])\n@token_required\ndef get_communities():",
        "detail": "Community.app",
        "documentation": {}
    },
    {
        "label": "socketio",
        "kind": 5,
        "importPath": "Community.app",
        "description": "Community.app",
        "peekOfCode": "socketio = SocketIO(app, cors_allowed_origins=\"*\")\n# room_name: set(usernames)\ncommunities = {}\n@app.route(\"/\")\ndef index():\n    return render_template('index.html')\n@app.route(\"/communities\", methods=['GET'])\n@token_required\ndef get_communities():\n    return jsonify(list(communities.keys()))",
        "detail": "Community.app",
        "documentation": {}
    },
    {
        "label": "communities",
        "kind": 5,
        "importPath": "Community.app",
        "description": "Community.app",
        "peekOfCode": "communities = {}\n@app.route(\"/\")\ndef index():\n    return render_template('index.html')\n@app.route(\"/communities\", methods=['GET'])\n@token_required\ndef get_communities():\n    return jsonify(list(communities.keys()))\n@app.route(\"/add_community\", methods=['POST'])\n@token_required",
        "detail": "Community.app",
        "documentation": {}
    },
    {
        "label": "validate_required_fields",
        "kind": 2,
        "importPath": "Crop Recommendation.app",
        "description": "Crop Recommendation.app",
        "peekOfCode": "def validate_required_fields(required_fields):\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            for field in required_fields:\n                if field not in request.form or not request.form[field].strip():\n                    return jsonify({'error': f'Missing required field: {field}'}), 400\n            return f(*args, **kwargs)\n        return decorated_function\n    return decorator",
        "detail": "Crop Recommendation.app",
        "documentation": {}
    },
    {
        "label": "sanitize_numeric_input",
        "kind": 2,
        "importPath": "Crop Recommendation.app",
        "description": "Crop Recommendation.app",
        "peekOfCode": "def sanitize_numeric_input(value, min_val=None, max_val=None, field_name=\"\"):\n    \"\"\"Sanitize and validate numeric input\"\"\"\n    try:\n        # Remove any non-numeric characters except decimal point and minus\n        cleaned = re.sub(r'[^0-9.-]', '', str(value))\n        num_value = float(cleaned)\n        if min_val is not None and num_value < min_val:\n            raise ValueError(f\"{field_name} must be at least {min_val}\")\n        if max_val is not None and num_value > max_val:\n            raise ValueError(f\"{field_name} must be at most {max_val}\")",
        "detail": "Crop Recommendation.app",
        "documentation": {}
    },
    {
        "label": "sanitize_input",
        "kind": 2,
        "importPath": "Crop Recommendation.app",
        "description": "Crop Recommendation.app",
        "peekOfCode": "def sanitize_input(text, max_length=255):\n    \"\"\"Sanitize text input\"\"\"\n    if not isinstance(text, str):\n        return \"\"\n    return text.strip()[:max_length]\n@app.route('/')\ndef home():\n    return render_template('index.html')\n@app.route('/predict', methods=['POST'])\n@token_required",
        "detail": "Crop Recommendation.app",
        "documentation": {}
    },
    {
        "label": "home",
        "kind": 2,
        "importPath": "Crop Recommendation.app",
        "description": "Crop Recommendation.app",
        "peekOfCode": "def home():\n    return render_template('index.html')\n@app.route('/predict', methods=['POST'])\n@token_required\n@roles_required('farmer', 'admin')\n@validate_required_fields(['N', 'P', 'K', 'temperature', 'humidity', 'ph', 'rainfall'])\ndef predict():\n    try:\n        # Sanitize and validate all numeric inputs\n        data = [",
        "detail": "Crop Recommendation.app",
        "documentation": {}
    },
    {
        "label": "predict",
        "kind": 2,
        "importPath": "Crop Recommendation.app",
        "description": "Crop Recommendation.app",
        "peekOfCode": "def predict():\n    try:\n        # Sanitize and validate all numeric inputs\n        data = [\n            sanitize_numeric_input(request.form['N'], 0, 200, \"Nitrogen (N)\"),\n            sanitize_numeric_input(request.form['P'], 0, 200, \"Phosphorus (P)\"),\n            sanitize_numeric_input(request.form['K'], 0, 200, \"Potassium (K)\"),\n            sanitize_numeric_input(request.form['temperature'], -50, 100, \"Temperature\"),\n            sanitize_numeric_input(request.form['humidity'], 0, 100, \"Humidity\"),\n            sanitize_numeric_input(request.form['ph'], 0, 14, \"pH\"),",
        "detail": "Crop Recommendation.app",
        "documentation": {}
    },
    {
        "label": "download_report",
        "kind": 2,
        "importPath": "Crop Recommendation.app",
        "description": "Crop Recommendation.app",
        "peekOfCode": "def download_report():\n    try:\n        # Sanitize inputs\n        crop = sanitize_input(request.form['crop'], 100)\n        params = {\n            'N': str(sanitize_numeric_input(request.form['N'], 0, 200, \"Nitrogen\")),\n            'P': str(sanitize_numeric_input(request.form['P'], 0, 200, \"Phosphorus\")),\n            'K': str(sanitize_numeric_input(request.form['K'], 0, 200, \"Potassium\")),\n            'temperature': str(sanitize_numeric_input(request.form['temperature'], -50, 100, \"Temperature\")),\n            'humidity': str(sanitize_numeric_input(request.form['humidity'], 0, 100, \"Humidity\")),",
        "detail": "Crop Recommendation.app",
        "documentation": {}
    },
    {
        "label": "bad_request",
        "kind": 2,
        "importPath": "Crop Recommendation.app",
        "description": "Crop Recommendation.app",
        "peekOfCode": "def bad_request(error):\n    return jsonify({'error': 'Bad request'}), 400\n@app.errorhandler(500)\ndef internal_error(error):\n    app.logger.error(f\"Internal error: {str(error)}\")\n    return jsonify({'error': 'Internal server error'}), 500\nif __name__ == '__main__':\n    app.run(debug=True, port=5501)",
        "detail": "Crop Recommendation.app",
        "documentation": {}
    },
    {
        "label": "internal_error",
        "kind": 2,
        "importPath": "Crop Recommendation.app",
        "description": "Crop Recommendation.app",
        "peekOfCode": "def internal_error(error):\n    app.logger.error(f\"Internal error: {str(error)}\")\n    return jsonify({'error': 'Internal server error'}), 500\nif __name__ == '__main__':\n    app.run(debug=True, port=5501)",
        "detail": "Crop Recommendation.app",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "Crop Recommendation.app",
        "description": "Crop Recommendation.app",
        "peekOfCode": "app = Flask(__name__)\nmodel = joblib.load('model/rf_model.pkl')\nlabel_encoder = joblib.load('model/label_encoder.pkl')  # Load encoder\n# Input validation helper functions\ndef validate_required_fields(required_fields):\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            for field in required_fields:\n                if field not in request.form or not request.form[field].strip():",
        "detail": "Crop Recommendation.app",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "Crop Recommendation.app",
        "description": "Crop Recommendation.app",
        "peekOfCode": "model = joblib.load('model/rf_model.pkl')\nlabel_encoder = joblib.load('model/label_encoder.pkl')  # Load encoder\n# Input validation helper functions\ndef validate_required_fields(required_fields):\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            for field in required_fields:\n                if field not in request.form or not request.form[field].strip():\n                    return jsonify({'error': f'Missing required field: {field}'}), 400",
        "detail": "Crop Recommendation.app",
        "documentation": {}
    },
    {
        "label": "label_encoder",
        "kind": 5,
        "importPath": "Crop Recommendation.app",
        "description": "Crop Recommendation.app",
        "peekOfCode": "label_encoder = joblib.load('model/label_encoder.pkl')  # Load encoder\n# Input validation helper functions\ndef validate_required_fields(required_fields):\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            for field in required_fields:\n                if field not in request.form or not request.form[field].strip():\n                    return jsonify({'error': f'Missing required field: {field}'}), 400\n            return f(*args, **kwargs)",
        "detail": "Crop Recommendation.app",
        "documentation": {}
    },
    {
        "label": "token_required",
        "kind": 2,
        "importPath": "Crop Recommendation.auth_utils",
        "description": "Crop Recommendation.auth_utils",
        "peekOfCode": "def token_required(f):\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        # For testing purposes, bypass authentication\n        return f(*args, **kwargs)\n    return decorated_function\ndef roles_required(*roles):\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):",
        "detail": "Crop Recommendation.auth_utils",
        "documentation": {}
    },
    {
        "label": "roles_required",
        "kind": 2,
        "importPath": "Crop Recommendation.auth_utils",
        "description": "Crop Recommendation.auth_utils",
        "peekOfCode": "def roles_required(*roles):\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            # For testing purposes, bypass role checking\n            return f(*args, **kwargs)\n        return decorated_function\n    return decorator",
        "detail": "Crop Recommendation.auth_utils",
        "documentation": {}
    },
    {
        "label": "csv_path",
        "kind": 5,
        "importPath": "Crop Recommendation.train_model",
        "description": "Crop Recommendation.train_model",
        "peekOfCode": "csv_path = './Crop_recommendation.csv'\ndf = pd.read_csv(csv_path)\n# Features and target\nX = df.drop('label', axis=1)\ny = df['label']\n# Encode target labels\nle = LabelEncoder()\ny_encoded = le.fit_transform(y)\n# Train model\nclf = RandomForestClassifier(n_estimators=100, random_state=42)",
        "detail": "Crop Recommendation.train_model",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "Crop Recommendation.train_model",
        "description": "Crop Recommendation.train_model",
        "peekOfCode": "df = pd.read_csv(csv_path)\n# Features and target\nX = df.drop('label', axis=1)\ny = df['label']\n# Encode target labels\nle = LabelEncoder()\ny_encoded = le.fit_transform(y)\n# Train model\nclf = RandomForestClassifier(n_estimators=100, random_state=42)\nclf.fit(X, y_encoded)",
        "detail": "Crop Recommendation.train_model",
        "documentation": {}
    },
    {
        "label": "X",
        "kind": 5,
        "importPath": "Crop Recommendation.train_model",
        "description": "Crop Recommendation.train_model",
        "peekOfCode": "X = df.drop('label', axis=1)\ny = df['label']\n# Encode target labels\nle = LabelEncoder()\ny_encoded = le.fit_transform(y)\n# Train model\nclf = RandomForestClassifier(n_estimators=100, random_state=42)\nclf.fit(X, y_encoded)\n# Save model and label encoder\njoblib.dump(clf, 'model/rf_model.pkl')",
        "detail": "Crop Recommendation.train_model",
        "documentation": {}
    },
    {
        "label": "y",
        "kind": 5,
        "importPath": "Crop Recommendation.train_model",
        "description": "Crop Recommendation.train_model",
        "peekOfCode": "y = df['label']\n# Encode target labels\nle = LabelEncoder()\ny_encoded = le.fit_transform(y)\n# Train model\nclf = RandomForestClassifier(n_estimators=100, random_state=42)\nclf.fit(X, y_encoded)\n# Save model and label encoder\njoblib.dump(clf, 'model/rf_model.pkl')\njoblib.dump(le, 'model/label_encoder.pkl')",
        "detail": "Crop Recommendation.train_model",
        "documentation": {}
    },
    {
        "label": "le",
        "kind": 5,
        "importPath": "Crop Recommendation.train_model",
        "description": "Crop Recommendation.train_model",
        "peekOfCode": "le = LabelEncoder()\ny_encoded = le.fit_transform(y)\n# Train model\nclf = RandomForestClassifier(n_estimators=100, random_state=42)\nclf.fit(X, y_encoded)\n# Save model and label encoder\njoblib.dump(clf, 'model/rf_model.pkl')\njoblib.dump(le, 'model/label_encoder.pkl')\nprint('Model and label encoder saved successfully!')",
        "detail": "Crop Recommendation.train_model",
        "documentation": {}
    },
    {
        "label": "y_encoded",
        "kind": 5,
        "importPath": "Crop Recommendation.train_model",
        "description": "Crop Recommendation.train_model",
        "peekOfCode": "y_encoded = le.fit_transform(y)\n# Train model\nclf = RandomForestClassifier(n_estimators=100, random_state=42)\nclf.fit(X, y_encoded)\n# Save model and label encoder\njoblib.dump(clf, 'model/rf_model.pkl')\njoblib.dump(le, 'model/label_encoder.pkl')\nprint('Model and label encoder saved successfully!')",
        "detail": "Crop Recommendation.train_model",
        "documentation": {}
    },
    {
        "label": "clf",
        "kind": 5,
        "importPath": "Crop Recommendation.train_model",
        "description": "Crop Recommendation.train_model",
        "peekOfCode": "clf = RandomForestClassifier(n_estimators=100, random_state=42)\nclf.fit(X, y_encoded)\n# Save model and label encoder\njoblib.dump(clf, 'model/rf_model.pkl')\njoblib.dump(le, 'model/label_encoder.pkl')\nprint('Model and label encoder saved successfully!')",
        "detail": "Crop Recommendation.train_model",
        "documentation": {}
    },
    {
        "label": "MockEncoder",
        "kind": 6,
        "importPath": "Crop Yield Prediction.crop_yield_app.app",
        "description": "Crop Yield Prediction.crop_yield_app.app",
        "peekOfCode": "class MockEncoder:\n    def __init__(self, classes):\n        self.classes_ = classes\n    def transform(self, values):\n        return [self.classes_.tolist().index(val) if val in self.classes_ else 0 for val in values]\n# Mock data\ncrop_encoder = MockEncoder(np.array([\"Rice\", \"Wheat\", \"Maize\", \"Cotton\", \"Sugarcane\", \"Soybean\", \"Groundnut\", \"Barley\", \"Ragi\", \"Jowar\"]))\nseason_encoder = MockEncoder(np.array([\"Kharif\", \"Rabi\", \"Summer\", \"Whole Year\"]))\nstate_encoder = MockEncoder(np.array([\"Andhra Pradesh\", \"Maharashtra\", \"Karnataka\", \"Tamil Nadu\", \"Uttar Pradesh\", \"Punjab\", \"Haryana\", \"Gujarat\", \"Rajasthan\", \"Madhya Pradesh\"]))\ndef mock_predict(features):",
        "detail": "Crop Yield Prediction.crop_yield_app.app",
        "documentation": {}
    },
    {
        "label": "mock_predict",
        "kind": 2,
        "importPath": "Crop Yield Prediction.crop_yield_app.app",
        "description": "Crop Yield Prediction.crop_yield_app.app",
        "peekOfCode": "def mock_predict(features):\n    \"\"\"Mock prediction function that returns a random yield value\"\"\"\n    # Simulate processing time\n    time.sleep(2)\n    # Return a mock prediction between 10-100 hg/ha\n    return np.random.uniform(10, 100, size=(len(features),))\nmodel = type('MockModel', (), {'predict': mock_predict})()\n# Input validation helper functions\ndef validate_required_fields(required_fields):\n    def decorator(f):",
        "detail": "Crop Yield Prediction.crop_yield_app.app",
        "documentation": {}
    },
    {
        "label": "validate_required_fields",
        "kind": 2,
        "importPath": "Crop Yield Prediction.crop_yield_app.app",
        "description": "Crop Yield Prediction.crop_yield_app.app",
        "peekOfCode": "def validate_required_fields(required_fields):\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            for field in required_fields:\n                if field not in request.form or not request.form[field].strip():\n                    return jsonify({'success': False, 'error': f'Missing required field: {field}'}), 400\n            return f(*args, **kwargs)\n        return decorated_function\n    return decorator",
        "detail": "Crop Yield Prediction.crop_yield_app.app",
        "documentation": {}
    },
    {
        "label": "sanitize_numeric_input",
        "kind": 2,
        "importPath": "Crop Yield Prediction.crop_yield_app.app",
        "description": "Crop Yield Prediction.crop_yield_app.app",
        "peekOfCode": "def sanitize_numeric_input(value, min_val=None, max_val=None, field_name=\"\"):\n    \"\"\"Sanitize and validate numeric input\"\"\"\n    try:\n        # Remove any non-numeric characters except decimal point and minus\n        cleaned = re.sub(r'[^0-9.-]', '', str(value))\n        num_value = float(cleaned)\n        if min_val is not None and num_value < min_val:\n            raise ValueError(f\"{field_name} must be at least {min_val}\")\n        if max_val is not None and num_value > max_val:\n            raise ValueError(f\"{field_name} must be at most {max_val}\")",
        "detail": "Crop Yield Prediction.crop_yield_app.app",
        "documentation": {}
    },
    {
        "label": "sanitize_input",
        "kind": 2,
        "importPath": "Crop Yield Prediction.crop_yield_app.app",
        "description": "Crop Yield Prediction.crop_yield_app.app",
        "peekOfCode": "def sanitize_input(text, max_length=255):\n    \"\"\"Sanitize text input\"\"\"\n    if not isinstance(text, str):\n        return \"\"\n    return text.strip()[:max_length]\ndef validate_year(year):\n    \"\"\"Validate year input\"\"\"\n    try:\n        year_int = int(year)\n        if year_int < 1900 or year_int > 2100:",
        "detail": "Crop Yield Prediction.crop_yield_app.app",
        "documentation": {}
    },
    {
        "label": "validate_year",
        "kind": 2,
        "importPath": "Crop Yield Prediction.crop_yield_app.app",
        "description": "Crop Yield Prediction.crop_yield_app.app",
        "peekOfCode": "def validate_year(year):\n    \"\"\"Validate year input\"\"\"\n    try:\n        year_int = int(year)\n        if year_int < 1900 or year_int > 2100:\n            raise ValueError(\"Year must be between 1900 and 2100\")\n        return year_int\n    except ValueError as e:\n        raise ValueError(f\"Invalid year: {str(e)}\")\n@app.route('/')",
        "detail": "Crop Yield Prediction.crop_yield_app.app",
        "documentation": {}
    },
    {
        "label": "index",
        "kind": 2,
        "importPath": "Crop Yield Prediction.crop_yield_app.app",
        "description": "Crop Yield Prediction.crop_yield_app.app",
        "peekOfCode": "def index():\n    return render_template('input.html')\n@validate_required_fields(['crop', 'year', 'season', 'state', 'area', 'production', 'rainfall'])\ndef predict():\n    try:\n        form = request.form\n        # Sanitize and validate all inputs\n        crop = sanitize_input(form['crop'], 50)\n        year = validate_year(form['year'])\n        season = sanitize_input(form['season'], 20)",
        "detail": "Crop Yield Prediction.crop_yield_app.app",
        "documentation": {}
    },
    {
        "label": "predict",
        "kind": 2,
        "importPath": "Crop Yield Prediction.crop_yield_app.app",
        "description": "Crop Yield Prediction.crop_yield_app.app",
        "peekOfCode": "def predict():\n    try:\n        form = request.form\n        # Sanitize and validate all inputs\n        crop = sanitize_input(form['crop'], 50)\n        year = validate_year(form['year'])\n        season = sanitize_input(form['season'], 20)\n        state = sanitize_input(form['state'], 50)\n        area = sanitize_numeric_input(form['area'], 0, 1000000, \"Area\")\n        production = sanitize_numeric_input(form['production'], 0, 1000000, \"Production\")",
        "detail": "Crop Yield Prediction.crop_yield_app.app",
        "documentation": {}
    },
    {
        "label": "bad_request",
        "kind": 2,
        "importPath": "Crop Yield Prediction.crop_yield_app.app",
        "description": "Crop Yield Prediction.crop_yield_app.app",
        "peekOfCode": "def bad_request(error):\n    return jsonify({'success': False, 'error': 'Bad request'}), 400\n@app.errorhandler(500)\ndef internal_error(error):\n    app.logger.error(f\"Internal error: {str(error)}\")\n    return jsonify({'success': False, 'error': 'Internal server error'}), 500\nif __name__ == '__main__':\n    app.run(debug=True, port=5502)",
        "detail": "Crop Yield Prediction.crop_yield_app.app",
        "documentation": {}
    },
    {
        "label": "internal_error",
        "kind": 2,
        "importPath": "Crop Yield Prediction.crop_yield_app.app",
        "description": "Crop Yield Prediction.crop_yield_app.app",
        "peekOfCode": "def internal_error(error):\n    app.logger.error(f\"Internal error: {str(error)}\")\n    return jsonify({'success': False, 'error': 'Internal server error'}), 500\nif __name__ == '__main__':\n    app.run(debug=True, port=5502)",
        "detail": "Crop Yield Prediction.crop_yield_app.app",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "Crop Yield Prediction.crop_yield_app.app",
        "description": "Crop Yield Prediction.crop_yield_app.app",
        "peekOfCode": "app = Flask(__name__)\n# Mock model and encoders for testing\nclass MockEncoder:\n    def __init__(self, classes):\n        self.classes_ = classes\n    def transform(self, values):\n        return [self.classes_.tolist().index(val) if val in self.classes_ else 0 for val in values]\n# Mock data\ncrop_encoder = MockEncoder(np.array([\"Rice\", \"Wheat\", \"Maize\", \"Cotton\", \"Sugarcane\", \"Soybean\", \"Groundnut\", \"Barley\", \"Ragi\", \"Jowar\"]))\nseason_encoder = MockEncoder(np.array([\"Kharif\", \"Rabi\", \"Summer\", \"Whole Year\"]))",
        "detail": "Crop Yield Prediction.crop_yield_app.app",
        "documentation": {}
    },
    {
        "label": "crop_encoder",
        "kind": 5,
        "importPath": "Crop Yield Prediction.crop_yield_app.app",
        "description": "Crop Yield Prediction.crop_yield_app.app",
        "peekOfCode": "crop_encoder = MockEncoder(np.array([\"Rice\", \"Wheat\", \"Maize\", \"Cotton\", \"Sugarcane\", \"Soybean\", \"Groundnut\", \"Barley\", \"Ragi\", \"Jowar\"]))\nseason_encoder = MockEncoder(np.array([\"Kharif\", \"Rabi\", \"Summer\", \"Whole Year\"]))\nstate_encoder = MockEncoder(np.array([\"Andhra Pradesh\", \"Maharashtra\", \"Karnataka\", \"Tamil Nadu\", \"Uttar Pradesh\", \"Punjab\", \"Haryana\", \"Gujarat\", \"Rajasthan\", \"Madhya Pradesh\"]))\ndef mock_predict(features):\n    \"\"\"Mock prediction function that returns a random yield value\"\"\"\n    # Simulate processing time\n    time.sleep(2)\n    # Return a mock prediction between 10-100 hg/ha\n    return np.random.uniform(10, 100, size=(len(features),))\nmodel = type('MockModel', (), {'predict': mock_predict})()",
        "detail": "Crop Yield Prediction.crop_yield_app.app",
        "documentation": {}
    },
    {
        "label": "season_encoder",
        "kind": 5,
        "importPath": "Crop Yield Prediction.crop_yield_app.app",
        "description": "Crop Yield Prediction.crop_yield_app.app",
        "peekOfCode": "season_encoder = MockEncoder(np.array([\"Kharif\", \"Rabi\", \"Summer\", \"Whole Year\"]))\nstate_encoder = MockEncoder(np.array([\"Andhra Pradesh\", \"Maharashtra\", \"Karnataka\", \"Tamil Nadu\", \"Uttar Pradesh\", \"Punjab\", \"Haryana\", \"Gujarat\", \"Rajasthan\", \"Madhya Pradesh\"]))\ndef mock_predict(features):\n    \"\"\"Mock prediction function that returns a random yield value\"\"\"\n    # Simulate processing time\n    time.sleep(2)\n    # Return a mock prediction between 10-100 hg/ha\n    return np.random.uniform(10, 100, size=(len(features),))\nmodel = type('MockModel', (), {'predict': mock_predict})()\n# Input validation helper functions",
        "detail": "Crop Yield Prediction.crop_yield_app.app",
        "documentation": {}
    },
    {
        "label": "state_encoder",
        "kind": 5,
        "importPath": "Crop Yield Prediction.crop_yield_app.app",
        "description": "Crop Yield Prediction.crop_yield_app.app",
        "peekOfCode": "state_encoder = MockEncoder(np.array([\"Andhra Pradesh\", \"Maharashtra\", \"Karnataka\", \"Tamil Nadu\", \"Uttar Pradesh\", \"Punjab\", \"Haryana\", \"Gujarat\", \"Rajasthan\", \"Madhya Pradesh\"]))\ndef mock_predict(features):\n    \"\"\"Mock prediction function that returns a random yield value\"\"\"\n    # Simulate processing time\n    time.sleep(2)\n    # Return a mock prediction between 10-100 hg/ha\n    return np.random.uniform(10, 100, size=(len(features),))\nmodel = type('MockModel', (), {'predict': mock_predict})()\n# Input validation helper functions\ndef validate_required_fields(required_fields):",
        "detail": "Crop Yield Prediction.crop_yield_app.app",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "Crop Yield Prediction.crop_yield_app.app",
        "description": "Crop Yield Prediction.crop_yield_app.app",
        "peekOfCode": "model = type('MockModel', (), {'predict': mock_predict})()\n# Input validation helper functions\ndef validate_required_fields(required_fields):\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            for field in required_fields:\n                if field not in request.form or not request.form[field].strip():\n                    return jsonify({'success': False, 'error': f'Missing required field: {field}'}), 400\n            return f(*args, **kwargs)",
        "detail": "Crop Yield Prediction.crop_yield_app.app",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "Crop Yield Prediction.crop_yield_predictor",
        "description": "Crop Yield Prediction.crop_yield_predictor",
        "peekOfCode": "df = pd.read_csv(\"data/crop_yield_dataset.csv\")  # Replace with your filename\n# Rename columns if needed\ndf.columns = df.columns.str.strip().str.replace(\" \", \"_\").str.lower()\n# Encode categorical variables\nle_area = LabelEncoder()\nle_item = LabelEncoder()\ndf['area_encoded'] = le_area.fit_transform(df['area'])\ndf['item_encoded'] = le_item.fit_transform(df['item'])\n# Feature selection\nfeatures = ['area_encoded', 'item_encoded', 'average_rain_fall_mm_per_year', 'pesticides_tonnes', 'avg_temp']",
        "detail": "Crop Yield Prediction.crop_yield_predictor",
        "documentation": {}
    },
    {
        "label": "df.columns",
        "kind": 5,
        "importPath": "Crop Yield Prediction.crop_yield_predictor",
        "description": "Crop Yield Prediction.crop_yield_predictor",
        "peekOfCode": "df.columns = df.columns.str.strip().str.replace(\" \", \"_\").str.lower()\n# Encode categorical variables\nle_area = LabelEncoder()\nle_item = LabelEncoder()\ndf['area_encoded'] = le_area.fit_transform(df['area'])\ndf['item_encoded'] = le_item.fit_transform(df['item'])\n# Feature selection\nfeatures = ['area_encoded', 'item_encoded', 'average_rain_fall_mm_per_year', 'pesticides_tonnes', 'avg_temp']\ntarget = 'hg/ha_yield'\nX = df[features]",
        "detail": "Crop Yield Prediction.crop_yield_predictor",
        "documentation": {}
    },
    {
        "label": "le_area",
        "kind": 5,
        "importPath": "Crop Yield Prediction.crop_yield_predictor",
        "description": "Crop Yield Prediction.crop_yield_predictor",
        "peekOfCode": "le_area = LabelEncoder()\nle_item = LabelEncoder()\ndf['area_encoded'] = le_area.fit_transform(df['area'])\ndf['item_encoded'] = le_item.fit_transform(df['item'])\n# Feature selection\nfeatures = ['area_encoded', 'item_encoded', 'average_rain_fall_mm_per_year', 'pesticides_tonnes', 'avg_temp']\ntarget = 'hg/ha_yield'\nX = df[features]\ny = df[target]\n# Train/Test split",
        "detail": "Crop Yield Prediction.crop_yield_predictor",
        "documentation": {}
    },
    {
        "label": "le_item",
        "kind": 5,
        "importPath": "Crop Yield Prediction.crop_yield_predictor",
        "description": "Crop Yield Prediction.crop_yield_predictor",
        "peekOfCode": "le_item = LabelEncoder()\ndf['area_encoded'] = le_area.fit_transform(df['area'])\ndf['item_encoded'] = le_item.fit_transform(df['item'])\n# Feature selection\nfeatures = ['area_encoded', 'item_encoded', 'average_rain_fall_mm_per_year', 'pesticides_tonnes', 'avg_temp']\ntarget = 'hg/ha_yield'\nX = df[features]\ny = df[target]\n# Train/Test split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)",
        "detail": "Crop Yield Prediction.crop_yield_predictor",
        "documentation": {}
    },
    {
        "label": "df['area_encoded']",
        "kind": 5,
        "importPath": "Crop Yield Prediction.crop_yield_predictor",
        "description": "Crop Yield Prediction.crop_yield_predictor",
        "peekOfCode": "df['area_encoded'] = le_area.fit_transform(df['area'])\ndf['item_encoded'] = le_item.fit_transform(df['item'])\n# Feature selection\nfeatures = ['area_encoded', 'item_encoded', 'average_rain_fall_mm_per_year', 'pesticides_tonnes', 'avg_temp']\ntarget = 'hg/ha_yield'\nX = df[features]\ny = df[target]\n# Train/Test split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n# Model training",
        "detail": "Crop Yield Prediction.crop_yield_predictor",
        "documentation": {}
    },
    {
        "label": "df['item_encoded']",
        "kind": 5,
        "importPath": "Crop Yield Prediction.crop_yield_predictor",
        "description": "Crop Yield Prediction.crop_yield_predictor",
        "peekOfCode": "df['item_encoded'] = le_item.fit_transform(df['item'])\n# Feature selection\nfeatures = ['area_encoded', 'item_encoded', 'average_rain_fall_mm_per_year', 'pesticides_tonnes', 'avg_temp']\ntarget = 'hg/ha_yield'\nX = df[features]\ny = df[target]\n# Train/Test split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n# Model training\nmodel = RandomForestRegressor(n_estimators=100, random_state=42)",
        "detail": "Crop Yield Prediction.crop_yield_predictor",
        "documentation": {}
    },
    {
        "label": "features",
        "kind": 5,
        "importPath": "Crop Yield Prediction.crop_yield_predictor",
        "description": "Crop Yield Prediction.crop_yield_predictor",
        "peekOfCode": "features = ['area_encoded', 'item_encoded', 'average_rain_fall_mm_per_year', 'pesticides_tonnes', 'avg_temp']\ntarget = 'hg/ha_yield'\nX = df[features]\ny = df[target]\n# Train/Test split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n# Model training\nmodel = RandomForestRegressor(n_estimators=100, random_state=42)\nmodel.fit(X_train, y_train)\n# Evaluate",
        "detail": "Crop Yield Prediction.crop_yield_predictor",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "Crop Yield Prediction.crop_yield_predictor",
        "description": "Crop Yield Prediction.crop_yield_predictor",
        "peekOfCode": "target = 'hg/ha_yield'\nX = df[features]\ny = df[target]\n# Train/Test split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n# Model training\nmodel = RandomForestRegressor(n_estimators=100, random_state=42)\nmodel.fit(X_train, y_train)\n# Evaluate\ny_pred = model.predict(X_test)",
        "detail": "Crop Yield Prediction.crop_yield_predictor",
        "documentation": {}
    },
    {
        "label": "X",
        "kind": 5,
        "importPath": "Crop Yield Prediction.crop_yield_predictor",
        "description": "Crop Yield Prediction.crop_yield_predictor",
        "peekOfCode": "X = df[features]\ny = df[target]\n# Train/Test split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n# Model training\nmodel = RandomForestRegressor(n_estimators=100, random_state=42)\nmodel.fit(X_train, y_train)\n# Evaluate\ny_pred = model.predict(X_test)\nmse = mean_squared_error(y_test, y_pred)",
        "detail": "Crop Yield Prediction.crop_yield_predictor",
        "documentation": {}
    },
    {
        "label": "y",
        "kind": 5,
        "importPath": "Crop Yield Prediction.crop_yield_predictor",
        "description": "Crop Yield Prediction.crop_yield_predictor",
        "peekOfCode": "y = df[target]\n# Train/Test split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n# Model training\nmodel = RandomForestRegressor(n_estimators=100, random_state=42)\nmodel.fit(X_train, y_train)\n# Evaluate\ny_pred = model.predict(X_test)\nmse = mean_squared_error(y_test, y_pred)\nfrom sklearn.metrics import r2_score",
        "detail": "Crop Yield Prediction.crop_yield_predictor",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "Crop Yield Prediction.crop_yield_predictor",
        "description": "Crop Yield Prediction.crop_yield_predictor",
        "peekOfCode": "model = RandomForestRegressor(n_estimators=100, random_state=42)\nmodel.fit(X_train, y_train)\n# Evaluate\ny_pred = model.predict(X_test)\nmse = mean_squared_error(y_test, y_pred)\nfrom sklearn.metrics import r2_score\nr2 = r2_score(y_test, y_pred)\nprint(f\"‚úÖ Model trained. Prediction Accuracy: {r2 * 100:.2f}%\")\n# Save model and encoders\njoblib.dump(model, 'yield_predictor_model.pkl')",
        "detail": "Crop Yield Prediction.crop_yield_predictor",
        "documentation": {}
    },
    {
        "label": "y_pred",
        "kind": 5,
        "importPath": "Crop Yield Prediction.crop_yield_predictor",
        "description": "Crop Yield Prediction.crop_yield_predictor",
        "peekOfCode": "y_pred = model.predict(X_test)\nmse = mean_squared_error(y_test, y_pred)\nfrom sklearn.metrics import r2_score\nr2 = r2_score(y_test, y_pred)\nprint(f\"‚úÖ Model trained. Prediction Accuracy: {r2 * 100:.2f}%\")\n# Save model and encoders\njoblib.dump(model, 'yield_predictor_model.pkl')\njoblib.dump(le_area, 'area_encoder.pkl')\njoblib.dump(le_item, 'item_encoder.pkl')",
        "detail": "Crop Yield Prediction.crop_yield_predictor",
        "documentation": {}
    },
    {
        "label": "mse",
        "kind": 5,
        "importPath": "Crop Yield Prediction.crop_yield_predictor",
        "description": "Crop Yield Prediction.crop_yield_predictor",
        "peekOfCode": "mse = mean_squared_error(y_test, y_pred)\nfrom sklearn.metrics import r2_score\nr2 = r2_score(y_test, y_pred)\nprint(f\"‚úÖ Model trained. Prediction Accuracy: {r2 * 100:.2f}%\")\n# Save model and encoders\njoblib.dump(model, 'yield_predictor_model.pkl')\njoblib.dump(le_area, 'area_encoder.pkl')\njoblib.dump(le_item, 'item_encoder.pkl')",
        "detail": "Crop Yield Prediction.crop_yield_predictor",
        "documentation": {}
    },
    {
        "label": "r2",
        "kind": 5,
        "importPath": "Crop Yield Prediction.crop_yield_predictor",
        "description": "Crop Yield Prediction.crop_yield_predictor",
        "peekOfCode": "r2 = r2_score(y_test, y_pred)\nprint(f\"‚úÖ Model trained. Prediction Accuracy: {r2 * 100:.2f}%\")\n# Save model and encoders\njoblib.dump(model, 'yield_predictor_model.pkl')\njoblib.dump(le_area, 'area_encoder.pkl')\njoblib.dump(le_item, 'item_encoder.pkl')",
        "detail": "Crop Yield Prediction.crop_yield_predictor",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "Crop Yield Prediction.predict",
        "description": "Crop Yield Prediction.predict",
        "peekOfCode": "model = joblib.load('yield_predictor_model.pkl')\nle_area = joblib.load('area_encoder.pkl')\nle_item = joblib.load('item_encoder.pkl')\n# Page config\nst.set_page_config(page_title=\"Crop Yield Predictor\", page_icon=\"üåæ\", layout=\"centered\")\n# Title\nst.title(\"üåæ Crop Yield Predictor\")\nst.write(\"Predict agricultural crop yield (in hg/ha) using region and climate data.\")\n# Input form\nwith st.form(\"input_form\"):",
        "detail": "Crop Yield Prediction.predict",
        "documentation": {}
    },
    {
        "label": "le_area",
        "kind": 5,
        "importPath": "Crop Yield Prediction.predict",
        "description": "Crop Yield Prediction.predict",
        "peekOfCode": "le_area = joblib.load('area_encoder.pkl')\nle_item = joblib.load('item_encoder.pkl')\n# Page config\nst.set_page_config(page_title=\"Crop Yield Predictor\", page_icon=\"üåæ\", layout=\"centered\")\n# Title\nst.title(\"üåæ Crop Yield Predictor\")\nst.write(\"Predict agricultural crop yield (in hg/ha) using region and climate data.\")\n# Input form\nwith st.form(\"input_form\"):\n    st.subheader(\"Enter Details:\")",
        "detail": "Crop Yield Prediction.predict",
        "documentation": {}
    },
    {
        "label": "le_item",
        "kind": 5,
        "importPath": "Crop Yield Prediction.predict",
        "description": "Crop Yield Prediction.predict",
        "peekOfCode": "le_item = joblib.load('item_encoder.pkl')\n# Page config\nst.set_page_config(page_title=\"Crop Yield Predictor\", page_icon=\"üåæ\", layout=\"centered\")\n# Title\nst.title(\"üåæ Crop Yield Predictor\")\nst.write(\"Predict agricultural crop yield (in hg/ha) using region and climate data.\")\n# Input form\nwith st.form(\"input_form\"):\n    st.subheader(\"Enter Details:\")\n    col1, col2 = st.columns(2)",
        "detail": "Crop Yield Prediction.predict",
        "documentation": {}
    },
    {
        "label": "sanitize_input",
        "kind": 2,
        "importPath": "Crop_Planning.app",
        "description": "Crop_Planning.app",
        "peekOfCode": "def sanitize_input(text, max_length=255):\n    \"\"\"Sanitize text input\"\"\"\n    if not isinstance(text, str):\n        return \"\"\n    # Remove potentially dangerous characters\n    cleaned = re.sub(r'[<>\"\\']', '', text.strip())\n    return cleaned[:max_length]\ndef validate_required_fields(required_fields):\n    def decorator(f):\n        @wraps(f)",
        "detail": "Crop_Planning.app",
        "documentation": {}
    },
    {
        "label": "validate_required_fields",
        "kind": 2,
        "importPath": "Crop_Planning.app",
        "description": "Crop_Planning.app",
        "peekOfCode": "def validate_required_fields(required_fields):\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            json_data = request.get_json()\n            if not json_data:\n                return jsonify({'error': 'Invalid JSON data'}), 400\n            for field in required_fields:\n                if field not in json_data or not json_data[field].strip():\n                    return jsonify({'error': f'Missing required field: {field}'}), 400",
        "detail": "Crop_Planning.app",
        "documentation": {}
    },
    {
        "label": "validate_user_data",
        "kind": 2,
        "importPath": "Crop_Planning.app",
        "description": "Crop_Planning.app",
        "peekOfCode": "def validate_user_data(data):\n    \"\"\"Validate user input data\"\"\"\n    required_fields = ['season', 'soil_type', 'climate', 'water_availability']\n    for field in required_fields:\n        if field not in data or not data[field].strip():\n            return False, f\"Missing required field: {field}\"\n    # Validate field lengths\n    for field, value in data.items():\n        if len(value) > 100:\n            return False, f\"{field} too long (max 100 characters)\"",
        "detail": "Crop_Planning.app",
        "documentation": {}
    },
    {
        "label": "clean_ai_response",
        "kind": 2,
        "importPath": "Crop_Planning.app",
        "description": "Crop_Planning.app",
        "peekOfCode": "def clean_ai_response(text_response):\n    start = text_response.find('{')\n    end = text_response.rfind('}')\n    if start != -1 and end != -1:\n        return text_response[start:end+1]\n    return text_response\ndef get_ai_prediction_and_guide(user_data):\n    if not genai_model:\n        return json.dumps({\"error\": \"AI model is not configured.\"})\n    # Sanitize user data before sending to AI",
        "detail": "Crop_Planning.app",
        "documentation": {}
    },
    {
        "label": "get_ai_prediction_and_guide",
        "kind": 2,
        "importPath": "Crop_Planning.app",
        "description": "Crop_Planning.app",
        "peekOfCode": "def get_ai_prediction_and_guide(user_data):\n    if not genai_model:\n        return json.dumps({\"error\": \"AI model is not configured.\"})\n    # Sanitize user data before sending to AI\n    sanitized_data = {k: sanitize_input(v, 100) for k, v in user_data.items()}\n    conditions = \", \".join([f\"{key.replace('_', ' ')}: {value}\" for key, value in sanitized_data.items()])\n    # FINAL, MOST STRICT PROMPT\n    prompt = f\"\"\"\n    You are a JSON API that provides agricultural advice.\n    Your entire response MUST be a single, valid JSON object and nothing else.",
        "detail": "Crop_Planning.app",
        "documentation": {}
    },
    {
        "label": "home",
        "kind": 2,
        "importPath": "Crop_Planning.app",
        "description": "Crop_Planning.app",
        "peekOfCode": "def home():\n    return render_template('cropplan.html')\n@app.route('/predict', methods=['POST'])\n@token_required\n@roles_required('farmer', 'admin')\n@validate_required_fields(['data'])\ndef predict():\n    try:\n        # Validate content type\n        if not request.is_json:",
        "detail": "Crop_Planning.app",
        "documentation": {}
    },
    {
        "label": "predict",
        "kind": 2,
        "importPath": "Crop_Planning.app",
        "description": "Crop_Planning.app",
        "peekOfCode": "def predict():\n    try:\n        # Validate content type\n        if not request.is_json:\n            return jsonify({\n                'error': True,\n                'message': 'Content-Type must be application/json',\n                'code': 400\n            }), 400\n        json_data = request.get_json()",
        "detail": "Crop_Planning.app",
        "documentation": {}
    },
    {
        "label": "bad_request",
        "kind": 2,
        "importPath": "Crop_Planning.app",
        "description": "Crop_Planning.app",
        "peekOfCode": "def bad_request(error):\n    app.logger.warning(f\"400 Bad Request: {str(error)}\")\n    return jsonify({\n        'error': True,\n        'message': 'Bad request',\n        'code': 400\n    }), 400\n@app.errorhandler(404)\ndef not_found(error):\n    app.logger.warning(f\"404 Not Found: {str(error)}\")",
        "detail": "Crop_Planning.app",
        "documentation": {}
    },
    {
        "label": "not_found",
        "kind": 2,
        "importPath": "Crop_Planning.app",
        "description": "Crop_Planning.app",
        "peekOfCode": "def not_found(error):\n    app.logger.warning(f\"404 Not Found: {str(error)}\")\n    return jsonify({\n        'error': True,\n        'message': 'Resource not found',\n        'code': 404\n    }), 404\n@app.errorhandler(500)\ndef internal_error(error):\n    app.logger.error(f\"500 Internal Server Error: {str(error)}\")",
        "detail": "Crop_Planning.app",
        "documentation": {}
    },
    {
        "label": "internal_error",
        "kind": 2,
        "importPath": "Crop_Planning.app",
        "description": "Crop_Planning.app",
        "peekOfCode": "def internal_error(error):\n    app.logger.error(f\"500 Internal Server Error: {str(error)}\")\n    return jsonify({\n        'error': True,\n        'message': 'Internal server error',\n        'code': 500\n    }), 500\nif __name__ == '__main__':\n    app.run(port=5003, debug=True)",
        "detail": "Crop_Planning.app",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "Crop_Planning.app",
        "description": "Crop_Planning.app",
        "peekOfCode": "app = Flask(__name__)\nCORS(app)\nAPI_KEY = \"AIzaSyC4MuJYakQd4T-T74c6kfZ9KBpZNzukJ8Q\"\n# Input validation helper functions\ndef sanitize_input(text, max_length=255):\n    \"\"\"Sanitize text input\"\"\"\n    if not isinstance(text, str):\n        return \"\"\n    # Remove potentially dangerous characters\n    cleaned = re.sub(r'[<>\"\\']', '', text.strip())",
        "detail": "Crop_Planning.app",
        "documentation": {}
    },
    {
        "label": "API_KEY",
        "kind": 5,
        "importPath": "Crop_Planning.app",
        "description": "Crop_Planning.app",
        "peekOfCode": "API_KEY = \"AIzaSyC4MuJYakQd4T-T74c6kfZ9KBpZNzukJ8Q\"\n# Input validation helper functions\ndef sanitize_input(text, max_length=255):\n    \"\"\"Sanitize text input\"\"\"\n    if not isinstance(text, str):\n        return \"\"\n    # Remove potentially dangerous characters\n    cleaned = re.sub(r'[<>\"\\']', '', text.strip())\n    return cleaned[:max_length]\ndef validate_required_fields(required_fields):",
        "detail": "Crop_Planning.app",
        "documentation": {}
    },
    {
        "label": "sanitize_input",
        "kind": 2,
        "importPath": "Crop_Prices_Tracker.app",
        "description": "Crop_Prices_Tracker.app",
        "peekOfCode": "def sanitize_input(text, max_length=255):\n    \"\"\"Sanitize text input\"\"\"\n    if not isinstance(text, str):\n        return \"\"\n    # Remove any potentially dangerous characters\n    cleaned = re.sub(r'[<>\"\\']', '', text.strip())\n    return cleaned[:max_length]\ndef validate_required_fields(required_fields):\n    def decorator(f):\n        @wraps(f)",
        "detail": "Crop_Prices_Tracker.app",
        "documentation": {}
    },
    {
        "label": "validate_required_fields",
        "kind": 2,
        "importPath": "Crop_Prices_Tracker.app",
        "description": "Crop_Prices_Tracker.app",
        "peekOfCode": "def validate_required_fields(required_fields):\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            for field in required_fields:\n                if field not in request.form or not request.form[field].strip():\n                    return jsonify({'error': f'Missing required field: {field}'}), 400\n            return f(*args, **kwargs)\n        return decorated_function\n    return decorator",
        "detail": "Crop_Prices_Tracker.app",
        "documentation": {}
    },
    {
        "label": "load_data",
        "kind": 2,
        "importPath": "Crop_Prices_Tracker.app",
        "description": "Crop_Prices_Tracker.app",
        "peekOfCode": "def load_data():\n    try:\n        response = requests.get(API_URL, params=API_PARAMS, timeout=10)\n        response.raise_for_status()\n        return response.json().get(\"records\", [])\n    except requests.RequestException as e:\n        app.logger.error(f\"API request failed: {str(e)}\")\n        return []\nDATA = load_data()\n@app.route('/')",
        "detail": "Crop_Prices_Tracker.app",
        "documentation": {}
    },
    {
        "label": "home",
        "kind": 2,
        "importPath": "Crop_Prices_Tracker.app",
        "description": "Crop_Prices_Tracker.app",
        "peekOfCode": "def home():\n    return redirect('/crop_price_tracker')\n@app.route('/crop_price_tracker', methods=['GET', 'POST'])\ndef crop_price_tracker():\n    try:\n        crops = sorted({record['commodity'] for record in DATA if record.get('commodity')})\n        result = []\n        error = None\n        if request.method == 'POST':\n            # Sanitize inputs",
        "detail": "Crop_Prices_Tracker.app",
        "documentation": {}
    },
    {
        "label": "crop_price_tracker",
        "kind": 2,
        "importPath": "Crop_Prices_Tracker.app",
        "description": "Crop_Prices_Tracker.app",
        "peekOfCode": "def crop_price_tracker():\n    try:\n        crops = sorted({record['commodity'] for record in DATA if record.get('commodity')})\n        result = []\n        error = None\n        if request.method == 'POST':\n            # Sanitize inputs\n            crop = sanitize_input(request.form.get('crop', ''), 100)\n            state = sanitize_input(request.form.get('state', ''), 100)\n            market = sanitize_input(request.form.get('market', ''), 100)",
        "detail": "Crop_Prices_Tracker.app",
        "documentation": {}
    },
    {
        "label": "get_states",
        "kind": 2,
        "importPath": "Crop_Prices_Tracker.app",
        "description": "Crop_Prices_Tracker.app",
        "peekOfCode": "def get_states():\n    try:\n        crop = sanitize_input(request.args.get('crop', ''), 100).lower()\n        if not crop:\n            return jsonify([])\n        states = sorted({r['state'] for r in DATA if r.get('commodity', '').lower() == crop})\n        return jsonify(states)\n    except Exception as e:\n        app.logger.error(f\"Get states error: {str(e)}\")\n        return jsonify([])",
        "detail": "Crop_Prices_Tracker.app",
        "documentation": {}
    },
    {
        "label": "get_markets",
        "kind": 2,
        "importPath": "Crop_Prices_Tracker.app",
        "description": "Crop_Prices_Tracker.app",
        "peekOfCode": "def get_markets():\n    try:\n        crop = sanitize_input(request.args.get('crop', ''), 100).lower()\n        state = sanitize_input(request.args.get('state', ''), 100).lower()\n        if not crop or not state:\n            return jsonify([])\n        markets = sorted({\n            r['market'] for r in DATA\n            if r.get('commodity', '').lower() == crop and r.get('state', '').lower() == state\n        })",
        "detail": "Crop_Prices_Tracker.app",
        "documentation": {}
    },
    {
        "label": "bad_request",
        "kind": 2,
        "importPath": "Crop_Prices_Tracker.app",
        "description": "Crop_Prices_Tracker.app",
        "peekOfCode": "def bad_request(error):\n    return jsonify({'error': 'Bad request'}), 400\n@app.errorhandler(500)\ndef internal_error(error):\n    app.logger.error(f\"Internal error: {str(error)}\")\n    return jsonify({'error': 'Internal server error'}), 500\nif __name__ == '__main__':\n    app.run(debug=True, port=5001)",
        "detail": "Crop_Prices_Tracker.app",
        "documentation": {}
    },
    {
        "label": "internal_error",
        "kind": 2,
        "importPath": "Crop_Prices_Tracker.app",
        "description": "Crop_Prices_Tracker.app",
        "peekOfCode": "def internal_error(error):\n    app.logger.error(f\"Internal error: {str(error)}\")\n    return jsonify({'error': 'Internal server error'}), 500\nif __name__ == '__main__':\n    app.run(debug=True, port=5001)",
        "detail": "Crop_Prices_Tracker.app",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "Crop_Prices_Tracker.app",
        "description": "Crop_Prices_Tracker.app",
        "peekOfCode": "app = Flask(__name__)\n# Global API config\nAPI_URL = \"https://api.data.gov.in/resource/9ef84268-d588-465a-a308-a864a43d0070\"\nAPI_PARAMS = {\n    \"api-key\": \"579b464db66ec23bdd000001c43ef34767ce496343897dfb1893102b\",\n    \"format\": \"json\",\n    \"limit\": 1000\n}\n# Input validation helper functions\ndef sanitize_input(text, max_length=255):",
        "detail": "Crop_Prices_Tracker.app",
        "documentation": {}
    },
    {
        "label": "API_URL",
        "kind": 5,
        "importPath": "Crop_Prices_Tracker.app",
        "description": "Crop_Prices_Tracker.app",
        "peekOfCode": "API_URL = \"https://api.data.gov.in/resource/9ef84268-d588-465a-a308-a864a43d0070\"\nAPI_PARAMS = {\n    \"api-key\": \"579b464db66ec23bdd000001c43ef34767ce496343897dfb1893102b\",\n    \"format\": \"json\",\n    \"limit\": 1000\n}\n# Input validation helper functions\ndef sanitize_input(text, max_length=255):\n    \"\"\"Sanitize text input\"\"\"\n    if not isinstance(text, str):",
        "detail": "Crop_Prices_Tracker.app",
        "documentation": {}
    },
    {
        "label": "API_PARAMS",
        "kind": 5,
        "importPath": "Crop_Prices_Tracker.app",
        "description": "Crop_Prices_Tracker.app",
        "peekOfCode": "API_PARAMS = {\n    \"api-key\": \"579b464db66ec23bdd000001c43ef34767ce496343897dfb1893102b\",\n    \"format\": \"json\",\n    \"limit\": 1000\n}\n# Input validation helper functions\ndef sanitize_input(text, max_length=255):\n    \"\"\"Sanitize text input\"\"\"\n    if not isinstance(text, str):\n        return \"\"",
        "detail": "Crop_Prices_Tracker.app",
        "documentation": {}
    },
    {
        "label": "DATA",
        "kind": 5,
        "importPath": "Crop_Prices_Tracker.app",
        "description": "Crop_Prices_Tracker.app",
        "peekOfCode": "DATA = load_data()\n@app.route('/')\ndef home():\n    return redirect('/crop_price_tracker')\n@app.route('/crop_price_tracker', methods=['GET', 'POST'])\ndef crop_price_tracker():\n    try:\n        crops = sorted({record['commodity'] for record in DATA if record.get('commodity')})\n        result = []\n        error = None",
        "detail": "Crop_Prices_Tracker.app",
        "documentation": {}
    },
    {
        "label": "allowed_file",
        "kind": 2,
        "importPath": "Disease prediction.app",
        "description": "Disease prediction.app",
        "peekOfCode": "def allowed_file(filename):\n    \"\"\"Check if file extension is allowed\"\"\"\n    return '.' in filename and \\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\ndef sanitize_filename(filename):\n    \"\"\"Sanitize filename to prevent path traversal attacks\"\"\"\n    if not filename:\n        return \"\"\n    # Remove any path separators and dangerous characters\n    cleaned = re.sub(r'[<>:\"/\\\\|?*]', '', filename)",
        "detail": "Disease prediction.app",
        "documentation": {}
    },
    {
        "label": "sanitize_filename",
        "kind": 2,
        "importPath": "Disease prediction.app",
        "description": "Disease prediction.app",
        "peekOfCode": "def sanitize_filename(filename):\n    \"\"\"Sanitize filename to prevent path traversal attacks\"\"\"\n    if not filename:\n        return \"\"\n    # Remove any path separators and dangerous characters\n    cleaned = re.sub(r'[<>:\"/\\\\|?*]', '', filename)\n    return secure_filename(cleaned)\ndef validate_file_size(file):\n    \"\"\"Validate file size\"\"\"\n    if file.content_length and file.content_length > MAX_FILE_SIZE:",
        "detail": "Disease prediction.app",
        "documentation": {}
    },
    {
        "label": "validate_file_size",
        "kind": 2,
        "importPath": "Disease prediction.app",
        "description": "Disease prediction.app",
        "peekOfCode": "def validate_file_size(file):\n    \"\"\"Validate file size\"\"\"\n    if file.content_length and file.content_length > MAX_FILE_SIZE:\n        return False\n    return True\n# Load the Keras model\ntry:\n    model = load_keras_model(r'disease/model.h5')\nexcept Exception as e:\n    app.logger.error(f\"Failed to load model: {str(e)}\")",
        "detail": "Disease prediction.app",
        "documentation": {}
    },
    {
        "label": "index",
        "kind": 2,
        "importPath": "Disease prediction.app",
        "description": "Disease prediction.app",
        "peekOfCode": "def index():\n    return render_template('index.html')\n# Route for prediction\n@app.route('/predict', methods=['POST'])\ndef predict():\n    try:\n        # Check if file was uploaded\n        if 'file' not in request.files:\n            return jsonify({'error': 'No file uploaded'}), 400\n        file = request.files['file']",
        "detail": "Disease prediction.app",
        "documentation": {}
    },
    {
        "label": "predict",
        "kind": 2,
        "importPath": "Disease prediction.app",
        "description": "Disease prediction.app",
        "peekOfCode": "def predict():\n    try:\n        # Check if file was uploaded\n        if 'file' not in request.files:\n            return jsonify({'error': 'No file uploaded'}), 400\n        file = request.files['file']\n        # Check if file was selected\n        if file.filename == '':\n            return jsonify({'error': 'No file selected'}), 400\n        # Validate file extension",
        "detail": "Disease prediction.app",
        "documentation": {}
    },
    {
        "label": "bad_request",
        "kind": 2,
        "importPath": "Disease prediction.app",
        "description": "Disease prediction.app",
        "peekOfCode": "def bad_request(error):\n    return jsonify({'error': 'Bad request'}), 400\n@app.errorhandler(413)\ndef too_large(error):\n    return jsonify({'error': 'File too large'}), 413\n@app.errorhandler(500)\ndef internal_error(error):\n    app.logger.error(f\"Internal error: {str(error)}\")\n    return jsonify({'error': 'Internal server error'}), 500\nif __name__ == '__main__':",
        "detail": "Disease prediction.app",
        "documentation": {}
    },
    {
        "label": "too_large",
        "kind": 2,
        "importPath": "Disease prediction.app",
        "description": "Disease prediction.app",
        "peekOfCode": "def too_large(error):\n    return jsonify({'error': 'File too large'}), 413\n@app.errorhandler(500)\ndef internal_error(error):\n    app.logger.error(f\"Internal error: {str(error)}\")\n    return jsonify({'error': 'Internal server error'}), 500\nif __name__ == '__main__':\n    app.run(debug=True)",
        "detail": "Disease prediction.app",
        "documentation": {}
    },
    {
        "label": "internal_error",
        "kind": 2,
        "importPath": "Disease prediction.app",
        "description": "Disease prediction.app",
        "peekOfCode": "def internal_error(error):\n    app.logger.error(f\"Internal error: {str(error)}\")\n    return jsonify({'error': 'Internal server error'}), 500\nif __name__ == '__main__':\n    app.run(debug=True)",
        "detail": "Disease prediction.app",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "Disease prediction.app",
        "description": "Disease prediction.app",
        "peekOfCode": "app = Flask(__name__)\nUPLOAD_FOLDER = r'disease/static/uploads'\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\nos.makedirs(UPLOAD_FOLDER, exist_ok=True)\n# Security configuration\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif', 'bmp'}\nMAX_FILE_SIZE = 16 * 1024 * 1024  # 16MB max file size\n# Input validation helper functions\ndef allowed_file(filename):\n    \"\"\"Check if file extension is allowed\"\"\"",
        "detail": "Disease prediction.app",
        "documentation": {}
    },
    {
        "label": "UPLOAD_FOLDER",
        "kind": 5,
        "importPath": "Disease prediction.app",
        "description": "Disease prediction.app",
        "peekOfCode": "UPLOAD_FOLDER = r'disease/static/uploads'\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\nos.makedirs(UPLOAD_FOLDER, exist_ok=True)\n# Security configuration\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif', 'bmp'}\nMAX_FILE_SIZE = 16 * 1024 * 1024  # 16MB max file size\n# Input validation helper functions\ndef allowed_file(filename):\n    \"\"\"Check if file extension is allowed\"\"\"\n    return '.' in filename and \\",
        "detail": "Disease prediction.app",
        "documentation": {}
    },
    {
        "label": "app.config['UPLOAD_FOLDER']",
        "kind": 5,
        "importPath": "Disease prediction.app",
        "description": "Disease prediction.app",
        "peekOfCode": "app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\nos.makedirs(UPLOAD_FOLDER, exist_ok=True)\n# Security configuration\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif', 'bmp'}\nMAX_FILE_SIZE = 16 * 1024 * 1024  # 16MB max file size\n# Input validation helper functions\ndef allowed_file(filename):\n    \"\"\"Check if file extension is allowed\"\"\"\n    return '.' in filename and \\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS",
        "detail": "Disease prediction.app",
        "documentation": {}
    },
    {
        "label": "ALLOWED_EXTENSIONS",
        "kind": 5,
        "importPath": "Disease prediction.app",
        "description": "Disease prediction.app",
        "peekOfCode": "ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif', 'bmp'}\nMAX_FILE_SIZE = 16 * 1024 * 1024  # 16MB max file size\n# Input validation helper functions\ndef allowed_file(filename):\n    \"\"\"Check if file extension is allowed\"\"\"\n    return '.' in filename and \\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\ndef sanitize_filename(filename):\n    \"\"\"Sanitize filename to prevent path traversal attacks\"\"\"\n    if not filename:",
        "detail": "Disease prediction.app",
        "documentation": {}
    },
    {
        "label": "MAX_FILE_SIZE",
        "kind": 5,
        "importPath": "Disease prediction.app",
        "description": "Disease prediction.app",
        "peekOfCode": "MAX_FILE_SIZE = 16 * 1024 * 1024  # 16MB max file size\n# Input validation helper functions\ndef allowed_file(filename):\n    \"\"\"Check if file extension is allowed\"\"\"\n    return '.' in filename and \\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\ndef sanitize_filename(filename):\n    \"\"\"Sanitize filename to prevent path traversal attacks\"\"\"\n    if not filename:\n        return \"\"",
        "detail": "Disease prediction.app",
        "documentation": {}
    },
    {
        "label": "PlantDiseaseNet",
        "kind": 6,
        "importPath": "Disease prediction.model",
        "description": "Disease prediction.model",
        "peekOfCode": "class PlantDiseaseNet(nn.Module):\n    def __init__(self, num_classes=38):  # original model had 38 classes\n        super(PlantDiseaseNet, self).__init__()\n        self.conv1 = nn.Sequential(\n            nn.Conv2d(3, 64, kernel_size=3, padding=1),\n            nn.BatchNorm2d(64),\n            nn.ReLU(inplace=True)\n        )\n        self.conv2 = nn.Sequential(\n            nn.Conv2d(64, 128, kernel_size=3, padding=1),",
        "detail": "Disease prediction.model",
        "documentation": {}
    },
    {
        "label": "load_keras_model",
        "kind": 2,
        "importPath": "Disease prediction.utils",
        "description": "Disease prediction.utils",
        "peekOfCode": "def load_keras_model(model_path):\n    model = load_model(model_path)\n    return model\ndef predict_image_keras(model, img_path):\n    img = image.load_img(img_path, target_size=(160, 160))  # Match your training size\n    img_array = image.img_to_array(img) / 255.0\n    img_array = np.expand_dims(img_array, axis=0)\n    predictions = model.predict(img_array)\n    predicted_index = np.argmax(predictions)\n    predicted_class = class_names[predicted_index]",
        "detail": "Disease prediction.utils",
        "documentation": {}
    },
    {
        "label": "predict_image_keras",
        "kind": 2,
        "importPath": "Disease prediction.utils",
        "description": "Disease prediction.utils",
        "peekOfCode": "def predict_image_keras(model, img_path):\n    img = image.load_img(img_path, target_size=(160, 160))  # Match your training size\n    img_array = image.img_to_array(img) / 255.0\n    img_array = np.expand_dims(img_array, axis=0)\n    predictions = model.predict(img_array)\n    predicted_index = np.argmax(predictions)\n    predicted_class = class_names[predicted_index]\n    description = class_descriptions.get(predicted_class, \"No description available.\")\n    return predicted_class, description",
        "detail": "Disease prediction.utils",
        "documentation": {}
    },
    {
        "label": "class_names",
        "kind": 5,
        "importPath": "Disease prediction.utils",
        "description": "Disease prediction.utils",
        "peekOfCode": "class_names = [\n    'Apple___Black_rot', 'Apple___healthy',\n    'Corn___Cercospora_leaf_spot', 'Corn___Common_rust',\n    'Corn___healthy', 'Grape___Black_rot', 'Grape___Esca',\n    'Grape___healthy', 'Potato___Early_blight', 'Potato___Late_blight',\n    'Potato___healthy', 'Tomato___Bacterial_spot', 'Tomato___Early_blight',\n    'Tomato___Late_blight', 'Tomato___Leaf_Mold', 'Tomato___Septoria_leaf_spot',\n    'Tomato___Spider_mites', 'Tomato___Target_Spot', 'Tomato___Yellow_Leaf_Curl_Virus',\n    'Tomato___mosaic_virus', 'Tomato___healthy'\n]",
        "detail": "Disease prediction.utils",
        "documentation": {}
    },
    {
        "label": "class_descriptions",
        "kind": 5,
        "importPath": "Disease prediction.utils",
        "description": "Disease prediction.utils",
        "peekOfCode": "class_descriptions = {\n    'Apple___Black_rot': 'Black rot is a fungal disease. Remove affected fruit and apply fungicide.',\n    'Apple___healthy': 'The apple plant is healthy.',\n    'Corn_(maize)___Cercospora_leaf_spot Gray_leaf_spot': 'Gray leaf spot detected. Use resistant varieties and rotate crops.',\n    'Corn_(maize)___Common_rust_': 'Common rust detected. Remove infected leaves and apply fungicide.',\n    'Corn_(maize)___healthy': 'The corn plant is healthy.',\n    'Grape___Black_rot': 'Black rot detected on grapes. Remove infected parts.',\n    'Grape___Esca_(Black_Measles)': 'Esca disease detected. Prune and burn affected wood.',\n    'Grape___healthy': 'The grape plant is healthy.',\n    'Potato___Early_blight': 'Early blight detected. Use certified disease-free seeds.',",
        "detail": "Disease prediction.utils",
        "documentation": {}
    },
    {
        "label": "decode_fertilizer",
        "kind": 2,
        "importPath": "Fertiliser Recommendation System.src.model",
        "description": "Fertiliser Recommendation System.src.model",
        "peekOfCode": "def decode_fertilizer(encoded_label):\n    if fertilizer_encoder is not None:\n        return fertilizer_encoder.inverse_transform([encoded_label])[0]\n    return \"Unknown\"\ndef predict_fertilizer(temparature, humidity, moisture, soil_type, crop_type, nitrogen, potassium, phosphorous):\n    if model is None or soil_encoder is None or crop_encoder is None:\n        return \"Error: Model not loaded.\"\n    # Encode categorical inputs\n    soil_type_encoded = soil_encoder.transform([soil_type])[0]\n    crop_type_encoded = crop_encoder.transform([crop_type])[0]",
        "detail": "Fertiliser Recommendation System.src.model",
        "documentation": {}
    },
    {
        "label": "predict_fertilizer",
        "kind": 2,
        "importPath": "Fertiliser Recommendation System.src.model",
        "description": "Fertiliser Recommendation System.src.model",
        "peekOfCode": "def predict_fertilizer(temparature, humidity, moisture, soil_type, crop_type, nitrogen, potassium, phosphorous):\n    if model is None or soil_encoder is None or crop_encoder is None:\n        return \"Error: Model not loaded.\"\n    # Encode categorical inputs\n    soil_type_encoded = soil_encoder.transform([soil_type])[0]\n    crop_type_encoded = crop_encoder.transform([crop_type])[0]\n    # Create input data matching training feature names exactly\n    input_data = pd.DataFrame([[\n        temparature, humidity, moisture,\n        soil_type_encoded, crop_type_encoded,",
        "detail": "Fertiliser Recommendation System.src.model",
        "documentation": {}
    },
    {
        "label": "df",
        "kind": 5,
        "importPath": "Fertiliser Recommendation System.src.train",
        "description": "Fertiliser Recommendation System.src.train",
        "peekOfCode": "df = pd.read_csv('../data/fertilizer_dataset.csv')\n# Encode categorical variables\ndf, soil_encoder, crop_encoder, fertilizer_encoder = encode_features(df)\n# Features and target\nX = df.drop(['Fertilizer Name'], axis=1)\ny = df['Fertilizer Name']\n# Train-test split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n# Hyperparameter tuning using GridSearchCV\nparam_grid = {",
        "detail": "Fertiliser Recommendation System.src.train",
        "documentation": {}
    },
    {
        "label": "X",
        "kind": 5,
        "importPath": "Fertiliser Recommendation System.src.train",
        "description": "Fertiliser Recommendation System.src.train",
        "peekOfCode": "X = df.drop(['Fertilizer Name'], axis=1)\ny = df['Fertilizer Name']\n# Train-test split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n# Hyperparameter tuning using GridSearchCV\nparam_grid = {\n    'n_estimators': [50, 100, 150, 200],\n    'max_depth': [None, 10, 20, 30],\n    'min_samples_split': [2, 5, 10],\n    'min_samples_leaf': [1, 2, 4]",
        "detail": "Fertiliser Recommendation System.src.train",
        "documentation": {}
    },
    {
        "label": "y",
        "kind": 5,
        "importPath": "Fertiliser Recommendation System.src.train",
        "description": "Fertiliser Recommendation System.src.train",
        "peekOfCode": "y = df['Fertilizer Name']\n# Train-test split\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n# Hyperparameter tuning using GridSearchCV\nparam_grid = {\n    'n_estimators': [50, 100, 150, 200],\n    'max_depth': [None, 10, 20, 30],\n    'min_samples_split': [2, 5, 10],\n    'min_samples_leaf': [1, 2, 4]\n}",
        "detail": "Fertiliser Recommendation System.src.train",
        "documentation": {}
    },
    {
        "label": "param_grid",
        "kind": 5,
        "importPath": "Fertiliser Recommendation System.src.train",
        "description": "Fertiliser Recommendation System.src.train",
        "peekOfCode": "param_grid = {\n    'n_estimators': [50, 100, 150, 200],\n    'max_depth': [None, 10, 20, 30],\n    'min_samples_split': [2, 5, 10],\n    'min_samples_leaf': [1, 2, 4]\n}\nrf = RandomForestClassifier(random_state=42)\ngrid_search = GridSearchCV(estimator=rf, param_grid=param_grid, cv=5, n_jobs=-1, verbose=2)\ngrid_search.fit(X_train, y_train)\n# Best model",
        "detail": "Fertiliser Recommendation System.src.train",
        "documentation": {}
    },
    {
        "label": "rf",
        "kind": 5,
        "importPath": "Fertiliser Recommendation System.src.train",
        "description": "Fertiliser Recommendation System.src.train",
        "peekOfCode": "rf = RandomForestClassifier(random_state=42)\ngrid_search = GridSearchCV(estimator=rf, param_grid=param_grid, cv=5, n_jobs=-1, verbose=2)\ngrid_search.fit(X_train, y_train)\n# Best model\nbest_clf = grid_search.best_estimator_\n# Evaluate model\ny_pred = best_clf.predict(X_test)\naccuracy = accuracy_score(y_test, y_pred)\nprint(f\"[INFO] Model accuracy after tuning: {accuracy:.2f}\")\n# Create directory to save model and encoders",
        "detail": "Fertiliser Recommendation System.src.train",
        "documentation": {}
    },
    {
        "label": "grid_search",
        "kind": 5,
        "importPath": "Fertiliser Recommendation System.src.train",
        "description": "Fertiliser Recommendation System.src.train",
        "peekOfCode": "grid_search = GridSearchCV(estimator=rf, param_grid=param_grid, cv=5, n_jobs=-1, verbose=2)\ngrid_search.fit(X_train, y_train)\n# Best model\nbest_clf = grid_search.best_estimator_\n# Evaluate model\ny_pred = best_clf.predict(X_test)\naccuracy = accuracy_score(y_test, y_pred)\nprint(f\"[INFO] Model accuracy after tuning: {accuracy:.2f}\")\n# Create directory to save model and encoders\nif not os.path.exists('../saved_model'):",
        "detail": "Fertiliser Recommendation System.src.train",
        "documentation": {}
    },
    {
        "label": "best_clf",
        "kind": 5,
        "importPath": "Fertiliser Recommendation System.src.train",
        "description": "Fertiliser Recommendation System.src.train",
        "peekOfCode": "best_clf = grid_search.best_estimator_\n# Evaluate model\ny_pred = best_clf.predict(X_test)\naccuracy = accuracy_score(y_test, y_pred)\nprint(f\"[INFO] Model accuracy after tuning: {accuracy:.2f}\")\n# Create directory to save model and encoders\nif not os.path.exists('../saved_model'):\n    os.makedirs('../saved_model')\n# Save model and encoders\njoblib.dump(best_clf, '../saved_model/fertilizer_model.pkl')",
        "detail": "Fertiliser Recommendation System.src.train",
        "documentation": {}
    },
    {
        "label": "y_pred",
        "kind": 5,
        "importPath": "Fertiliser Recommendation System.src.train",
        "description": "Fertiliser Recommendation System.src.train",
        "peekOfCode": "y_pred = best_clf.predict(X_test)\naccuracy = accuracy_score(y_test, y_pred)\nprint(f\"[INFO] Model accuracy after tuning: {accuracy:.2f}\")\n# Create directory to save model and encoders\nif not os.path.exists('../saved_model'):\n    os.makedirs('../saved_model')\n# Save model and encoders\njoblib.dump(best_clf, '../saved_model/fertilizer_model.pkl')\njoblib.dump(soil_encoder, '../saved_model/soil_encoder.pkl')\njoblib.dump(crop_encoder, '../saved_model/crop_encoder.pkl')",
        "detail": "Fertiliser Recommendation System.src.train",
        "documentation": {}
    },
    {
        "label": "accuracy",
        "kind": 5,
        "importPath": "Fertiliser Recommendation System.src.train",
        "description": "Fertiliser Recommendation System.src.train",
        "peekOfCode": "accuracy = accuracy_score(y_test, y_pred)\nprint(f\"[INFO] Model accuracy after tuning: {accuracy:.2f}\")\n# Create directory to save model and encoders\nif not os.path.exists('../saved_model'):\n    os.makedirs('../saved_model')\n# Save model and encoders\njoblib.dump(best_clf, '../saved_model/fertilizer_model.pkl')\njoblib.dump(soil_encoder, '../saved_model/soil_encoder.pkl')\njoblib.dump(crop_encoder, '../saved_model/crop_encoder.pkl')\njoblib.dump(fertilizer_encoder, '../saved_model/fertilizer_encoder.pkl')",
        "detail": "Fertiliser Recommendation System.src.train",
        "documentation": {}
    },
    {
        "label": "encode_features",
        "kind": 2,
        "importPath": "Fertiliser Recommendation System.src.utils",
        "description": "Fertiliser Recommendation System.src.utils",
        "peekOfCode": "def encode_features(df):\n    df['Soil Type'] = soil_encoder.fit_transform(df['Soil Type'])\n    df['Crop Type'] = crop_encoder.fit_transform(df['Crop Type'])\n    df['Fertilizer Name'] = fertilizer_encoder.fit_transform(df['Fertilizer Name'])\n    return df, soil_encoder, crop_encoder, fertilizer_encoder\ndef decode_fertilizer(encoded_label):\n    return fertilizer_encoder.inverse_transform([encoded_label])[0]",
        "detail": "Fertiliser Recommendation System.src.utils",
        "documentation": {}
    },
    {
        "label": "decode_fertilizer",
        "kind": 2,
        "importPath": "Fertiliser Recommendation System.src.utils",
        "description": "Fertiliser Recommendation System.src.utils",
        "peekOfCode": "def decode_fertilizer(encoded_label):\n    return fertilizer_encoder.inverse_transform([encoded_label])[0]",
        "detail": "Fertiliser Recommendation System.src.utils",
        "documentation": {}
    },
    {
        "label": "soil_encoder",
        "kind": 5,
        "importPath": "Fertiliser Recommendation System.src.utils",
        "description": "Fertiliser Recommendation System.src.utils",
        "peekOfCode": "soil_encoder = LabelEncoder()\ncrop_encoder = LabelEncoder()\nfertilizer_encoder = LabelEncoder()\ndef encode_features(df):\n    df['Soil Type'] = soil_encoder.fit_transform(df['Soil Type'])\n    df['Crop Type'] = crop_encoder.fit_transform(df['Crop Type'])\n    df['Fertilizer Name'] = fertilizer_encoder.fit_transform(df['Fertilizer Name'])\n    return df, soil_encoder, crop_encoder, fertilizer_encoder\ndef decode_fertilizer(encoded_label):\n    return fertilizer_encoder.inverse_transform([encoded_label])[0]",
        "detail": "Fertiliser Recommendation System.src.utils",
        "documentation": {}
    },
    {
        "label": "crop_encoder",
        "kind": 5,
        "importPath": "Fertiliser Recommendation System.src.utils",
        "description": "Fertiliser Recommendation System.src.utils",
        "peekOfCode": "crop_encoder = LabelEncoder()\nfertilizer_encoder = LabelEncoder()\ndef encode_features(df):\n    df['Soil Type'] = soil_encoder.fit_transform(df['Soil Type'])\n    df['Crop Type'] = crop_encoder.fit_transform(df['Crop Type'])\n    df['Fertilizer Name'] = fertilizer_encoder.fit_transform(df['Fertilizer Name'])\n    return df, soil_encoder, crop_encoder, fertilizer_encoder\ndef decode_fertilizer(encoded_label):\n    return fertilizer_encoder.inverse_transform([encoded_label])[0]",
        "detail": "Fertiliser Recommendation System.src.utils",
        "documentation": {}
    },
    {
        "label": "fertilizer_encoder",
        "kind": 5,
        "importPath": "Fertiliser Recommendation System.src.utils",
        "description": "Fertiliser Recommendation System.src.utils",
        "peekOfCode": "fertilizer_encoder = LabelEncoder()\ndef encode_features(df):\n    df['Soil Type'] = soil_encoder.fit_transform(df['Soil Type'])\n    df['Crop Type'] = crop_encoder.fit_transform(df['Crop Type'])\n    df['Fertilizer Name'] = fertilizer_encoder.fit_transform(df['Fertilizer Name'])\n    return df, soil_encoder, crop_encoder, fertilizer_encoder\ndef decode_fertilizer(encoded_label):\n    return fertilizer_encoder.inverse_transform([encoded_label])[0]",
        "detail": "Fertiliser Recommendation System.src.utils",
        "documentation": {}
    },
    {
        "label": "sanitize_input",
        "kind": 2,
        "importPath": "Forum.app",
        "description": "Forum.app",
        "peekOfCode": "def sanitize_input(text, max_length=1000):\n    \"\"\"Sanitize text input\"\"\"\n    if not isinstance(text, str):\n        return \"\"\n    # Remove potentially dangerous characters\n    cleaned = re.sub(r'[<>\"\\']', '', text.strip())\n    return cleaned[:max_length]\ndef validate_required_fields(required_fields):\n    def decorator(f):\n        @wraps(f)",
        "detail": "Forum.app",
        "documentation": {}
    },
    {
        "label": "validate_required_fields",
        "kind": 2,
        "importPath": "Forum.app",
        "description": "Forum.app",
        "peekOfCode": "def validate_required_fields(required_fields):\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            for field in required_fields:\n                if field not in request.get_json() or not request.get_json()[field].strip():\n                    return jsonify({'error': f'Missing required field: {field}'}), 400\n            return f(*args, **kwargs)\n        return decorated_function\n    return decorator",
        "detail": "Forum.app",
        "documentation": {}
    },
    {
        "label": "validate_post_data",
        "kind": 2,
        "importPath": "Forum.app",
        "description": "Forum.app",
        "peekOfCode": "def validate_post_data(data):\n    \"\"\"Validate forum post data\"\"\"\n    required_fields = ['title', 'content', 'author']\n    for field in required_fields:\n        if field not in data or not data[field].strip():\n            return False, f\"Missing required field: {field}\"\n    # Validate field lengths\n    if len(data['title']) > 200:\n        return False, \"Title too long (max 200 characters)\"\n    if len(data['content']) > 5000:",
        "detail": "Forum.app",
        "documentation": {}
    },
    {
        "label": "forum_api",
        "kind": 2,
        "importPath": "Forum.app",
        "description": "Forum.app",
        "peekOfCode": "def forum_api():\n    try:\n        if request.method == 'POST':\n            # Only allow farmers and admins to create posts\n            user = getattr(request, 'user', {})\n            if user.get('role') not in ['farmer', 'admin']:\n                return jsonify({'error': 'Insufficient permissions'}), 403\n            # Validate content type\n            if not request.is_json:\n                return jsonify({'error': 'Content-Type must be application/json'}), 400",
        "detail": "Forum.app",
        "documentation": {}
    },
    {
        "label": "bad_request",
        "kind": 2,
        "importPath": "Forum.app",
        "description": "Forum.app",
        "peekOfCode": "def bad_request(error):\n    return jsonify({'error': 'Bad request'}), 400\n@app.errorhandler(500)\ndef internal_error(error):\n    app.logger.error(f\"Internal error: {str(error)}\")\n    return jsonify({'error': 'Internal server error'}), 500\nif __name__ == '__main__':\n    app.run(port=5000, debug=True)",
        "detail": "Forum.app",
        "documentation": {}
    },
    {
        "label": "internal_error",
        "kind": 2,
        "importPath": "Forum.app",
        "description": "Forum.app",
        "peekOfCode": "def internal_error(error):\n    app.logger.error(f\"Internal error: {str(error)}\")\n    return jsonify({'error': 'Internal server error'}), 500\nif __name__ == '__main__':\n    app.run(port=5000, debug=True)",
        "detail": "Forum.app",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "Forum.app",
        "description": "Forum.app",
        "peekOfCode": "app = Flask(__name__)\nCORS(app)  # Allow frontend (Live Server) to call API\n# Input validation helper functions\ndef sanitize_input(text, max_length=1000):\n    \"\"\"Sanitize text input\"\"\"\n    if not isinstance(text, str):\n        return \"\"\n    # Remove potentially dangerous characters\n    cleaned = re.sub(r'[<>\"\\']', '', text.strip())\n    return cleaned[:max_length]",
        "detail": "Forum.app",
        "documentation": {}
    },
    {
        "label": "forum_posts",
        "kind": 5,
        "importPath": "Forum.app",
        "description": "Forum.app",
        "peekOfCode": "forum_posts = []\n@app.route('/forum', methods=['GET', 'POST'])\n@token_required\ndef forum_api():\n    try:\n        if request.method == 'POST':\n            # Only allow farmers and admins to create posts\n            user = getattr(request, 'user', {})\n            if user.get('role') not in ['farmer', 'admin']:\n                return jsonify({'error': 'Insufficient permissions'}), 403",
        "detail": "Forum.app",
        "documentation": {}
    },
    {
        "label": "get_news",
        "kind": 2,
        "importPath": "Labour_Alerts.app",
        "description": "Labour_Alerts.app",
        "peekOfCode": "def get_news():\n    try:\n        # Check cache first\n        current_time = time.time()\n        if 'news_data' in api_cache and (current_time - api_cache['timestamp']) < cache_duration:\n            return jsonify(api_cache['news_data'])\n        api_key = 'pub_9a1996b402894fa081be406a87c64f36' \n        api_url = f'https://newsdata.io/api/1/latest?apikey={api_key}&qInMeta=farming&language=hi&country=in'\n        # Add retry logic with exponential backoff\n        for attempt in range(MAX_RETRIES):",
        "detail": "Labour_Alerts.app",
        "documentation": {}
    },
    {
        "label": "bad_request",
        "kind": 2,
        "importPath": "Labour_Alerts.app",
        "description": "Labour_Alerts.app",
        "peekOfCode": "def bad_request(error):\n    return jsonify({'error': 'Bad request'}), 400\n@app.errorhandler(500)\ndef internal_error(error):\n    app.logger.error(f\"Internal error: {str(error)}\")\n    return jsonify({'error': 'Internal server error'}), 500\n@app.errorhandler(503)\ndef service_unavailable(error):\n    return jsonify({'error': 'Service temporarily unavailable'}), 503\nif __name__ == '__main__':",
        "detail": "Labour_Alerts.app",
        "documentation": {}
    },
    {
        "label": "internal_error",
        "kind": 2,
        "importPath": "Labour_Alerts.app",
        "description": "Labour_Alerts.app",
        "peekOfCode": "def internal_error(error):\n    app.logger.error(f\"Internal error: {str(error)}\")\n    return jsonify({'error': 'Internal server error'}), 500\n@app.errorhandler(503)\ndef service_unavailable(error):\n    return jsonify({'error': 'Service temporarily unavailable'}), 503\nif __name__ == '__main__':\n    app.run(port=5000, debug=True)",
        "detail": "Labour_Alerts.app",
        "documentation": {}
    },
    {
        "label": "service_unavailable",
        "kind": 2,
        "importPath": "Labour_Alerts.app",
        "description": "Labour_Alerts.app",
        "peekOfCode": "def service_unavailable(error):\n    return jsonify({'error': 'Service temporarily unavailable'}), 503\nif __name__ == '__main__':\n    app.run(port=5000, debug=True)",
        "detail": "Labour_Alerts.app",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "Labour_Alerts.app",
        "description": "Labour_Alerts.app",
        "peekOfCode": "app = Flask(__name__)\nCORS(app)  # <-- This line enables CORS for all routes\n# Security configuration\nAPI_TIMEOUT = 10  # seconds\nMAX_RETRIES = 3\nRATE_LIMIT_DELAY = 1  # seconds between requests\n# Cache for API responses to reduce API calls\napi_cache = {}\ncache_duration = 300  # 5 minutes\n@app.route('/news')",
        "detail": "Labour_Alerts.app",
        "documentation": {}
    },
    {
        "label": "API_TIMEOUT",
        "kind": 5,
        "importPath": "Labour_Alerts.app",
        "description": "Labour_Alerts.app",
        "peekOfCode": "API_TIMEOUT = 10  # seconds\nMAX_RETRIES = 3\nRATE_LIMIT_DELAY = 1  # seconds between requests\n# Cache for API responses to reduce API calls\napi_cache = {}\ncache_duration = 300  # 5 minutes\n@app.route('/news')\ndef get_news():\n    try:\n        # Check cache first",
        "detail": "Labour_Alerts.app",
        "documentation": {}
    },
    {
        "label": "MAX_RETRIES",
        "kind": 5,
        "importPath": "Labour_Alerts.app",
        "description": "Labour_Alerts.app",
        "peekOfCode": "MAX_RETRIES = 3\nRATE_LIMIT_DELAY = 1  # seconds between requests\n# Cache for API responses to reduce API calls\napi_cache = {}\ncache_duration = 300  # 5 minutes\n@app.route('/news')\ndef get_news():\n    try:\n        # Check cache first\n        current_time = time.time()",
        "detail": "Labour_Alerts.app",
        "documentation": {}
    },
    {
        "label": "RATE_LIMIT_DELAY",
        "kind": 5,
        "importPath": "Labour_Alerts.app",
        "description": "Labour_Alerts.app",
        "peekOfCode": "RATE_LIMIT_DELAY = 1  # seconds between requests\n# Cache for API responses to reduce API calls\napi_cache = {}\ncache_duration = 300  # 5 minutes\n@app.route('/news')\ndef get_news():\n    try:\n        # Check cache first\n        current_time = time.time()\n        if 'news_data' in api_cache and (current_time - api_cache['timestamp']) < cache_duration:",
        "detail": "Labour_Alerts.app",
        "documentation": {}
    },
    {
        "label": "api_cache",
        "kind": 5,
        "importPath": "Labour_Alerts.app",
        "description": "Labour_Alerts.app",
        "peekOfCode": "api_cache = {}\ncache_duration = 300  # 5 minutes\n@app.route('/news')\ndef get_news():\n    try:\n        # Check cache first\n        current_time = time.time()\n        if 'news_data' in api_cache and (current_time - api_cache['timestamp']) < cache_duration:\n            return jsonify(api_cache['news_data'])\n        api_key = 'pub_9a1996b402894fa081be406a87c64f36' ",
        "detail": "Labour_Alerts.app",
        "documentation": {}
    },
    {
        "label": "cache_duration",
        "kind": 5,
        "importPath": "Labour_Alerts.app",
        "description": "Labour_Alerts.app",
        "peekOfCode": "cache_duration = 300  # 5 minutes\n@app.route('/news')\ndef get_news():\n    try:\n        # Check cache first\n        current_time = time.time()\n        if 'news_data' in api_cache and (current_time - api_cache['timestamp']) < cache_duration:\n            return jsonify(api_cache['news_data'])\n        api_key = 'pub_9a1996b402894fa081be406a87c64f36' \n        api_url = f'https://newsdata.io/api/1/latest?apikey={api_key}&qInMeta=farming&language=hi&country=in'",
        "detail": "Labour_Alerts.app",
        "documentation": {}
    },
    {
        "label": "get_data_generators",
        "kind": 2,
        "importPath": "Soil Classifier CNN.src.data_loader",
        "description": "Soil Classifier CNN.src.data_loader",
        "peekOfCode": "def get_data_generators(data_dir, img_size=(128, 128), batch_size=32, val_split=0.2):\n    datagen = ImageDataGenerator(\n        rescale=1./255,\n        validation_split=val_split\n    )\n    train_generator = datagen.flow_from_directory(\n        data_dir,\n        target_size=img_size,\n        batch_size=batch_size,\n        class_mode='categorical',",
        "detail": "Soil Classifier CNN.src.data_loader",
        "documentation": {}
    },
    {
        "label": "build_cnn_model",
        "kind": 2,
        "importPath": "Soil Classifier CNN.src.model",
        "description": "Soil Classifier CNN.src.model",
        "peekOfCode": "def build_cnn_model(input_shape=(128, 128, 3), num_classes=5):\n    model = Sequential([\n        Conv2D(32, (3, 3), activation='relu', input_shape=input_shape),\n        MaxPooling2D(pool_size=(2, 2)),\n        Conv2D(64, (3, 3), activation='relu'),\n        MaxPooling2D(pool_size=(2, 2)),\n        Flatten(),\n        Dense(128, activation='relu'),\n        Dropout(0.5),\n        Dense(num_classes,activation='softmax')",
        "detail": "Soil Classifier CNN.src.model",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Soil Classifier CNN.src.train",
        "description": "Soil Classifier CNN.src.train",
        "peekOfCode": "def main():\n    # Step 1: Load Data\n    train_gen, val_gen = get_data_generators(DATASET_DIR, img_size=IMG_SIZE, batch_size=BATCH_SIZE)\n    # Step 2: Build Model\n    model = build_cnn_model(input_shape=(128, 128, 3), num_classes=train_gen.num_classes)\n    # Step 3: Train Model\n    history = model.fit(\n        train_gen,\n        validation_data=val_gen,\n        epochs=EPOCHS",
        "detail": "Soil Classifier CNN.src.train",
        "documentation": {}
    },
    {
        "label": "DATASET_DIR",
        "kind": 5,
        "importPath": "Soil Classifier CNN.src.train",
        "description": "Soil Classifier CNN.src.train",
        "peekOfCode": "DATASET_DIR = \"../dataset\"\nMODEL_PATH = \"../saved_model/soil_classifier_cnn.h5\"\nIMG_SIZE = (128, 128)\nBATCH_SIZE = 32\nEPOCHS = 20\ndef main():\n    # Step 1: Load Data\n    train_gen, val_gen = get_data_generators(DATASET_DIR, img_size=IMG_SIZE, batch_size=BATCH_SIZE)\n    # Step 2: Build Model\n    model = build_cnn_model(input_shape=(128, 128, 3), num_classes=train_gen.num_classes)",
        "detail": "Soil Classifier CNN.src.train",
        "documentation": {}
    },
    {
        "label": "MODEL_PATH",
        "kind": 5,
        "importPath": "Soil Classifier CNN.src.train",
        "description": "Soil Classifier CNN.src.train",
        "peekOfCode": "MODEL_PATH = \"../saved_model/soil_classifier_cnn.h5\"\nIMG_SIZE = (128, 128)\nBATCH_SIZE = 32\nEPOCHS = 20\ndef main():\n    # Step 1: Load Data\n    train_gen, val_gen = get_data_generators(DATASET_DIR, img_size=IMG_SIZE, batch_size=BATCH_SIZE)\n    # Step 2: Build Model\n    model = build_cnn_model(input_shape=(128, 128, 3), num_classes=train_gen.num_classes)\n    # Step 3: Train Model",
        "detail": "Soil Classifier CNN.src.train",
        "documentation": {}
    },
    {
        "label": "IMG_SIZE",
        "kind": 5,
        "importPath": "Soil Classifier CNN.src.train",
        "description": "Soil Classifier CNN.src.train",
        "peekOfCode": "IMG_SIZE = (128, 128)\nBATCH_SIZE = 32\nEPOCHS = 20\ndef main():\n    # Step 1: Load Data\n    train_gen, val_gen = get_data_generators(DATASET_DIR, img_size=IMG_SIZE, batch_size=BATCH_SIZE)\n    # Step 2: Build Model\n    model = build_cnn_model(input_shape=(128, 128, 3), num_classes=train_gen.num_classes)\n    # Step 3: Train Model\n    history = model.fit(",
        "detail": "Soil Classifier CNN.src.train",
        "documentation": {}
    },
    {
        "label": "BATCH_SIZE",
        "kind": 5,
        "importPath": "Soil Classifier CNN.src.train",
        "description": "Soil Classifier CNN.src.train",
        "peekOfCode": "BATCH_SIZE = 32\nEPOCHS = 20\ndef main():\n    # Step 1: Load Data\n    train_gen, val_gen = get_data_generators(DATASET_DIR, img_size=IMG_SIZE, batch_size=BATCH_SIZE)\n    # Step 2: Build Model\n    model = build_cnn_model(input_shape=(128, 128, 3), num_classes=train_gen.num_classes)\n    # Step 3: Train Model\n    history = model.fit(\n        train_gen,",
        "detail": "Soil Classifier CNN.src.train",
        "documentation": {}
    },
    {
        "label": "EPOCHS",
        "kind": 5,
        "importPath": "Soil Classifier CNN.src.train",
        "description": "Soil Classifier CNN.src.train",
        "peekOfCode": "EPOCHS = 20\ndef main():\n    # Step 1: Load Data\n    train_gen, val_gen = get_data_generators(DATASET_DIR, img_size=IMG_SIZE, batch_size=BATCH_SIZE)\n    # Step 2: Build Model\n    model = build_cnn_model(input_shape=(128, 128, 3), num_classes=train_gen.num_classes)\n    # Step 3: Train Model\n    history = model.fit(\n        train_gen,\n        validation_data=val_gen,",
        "detail": "Soil Classifier CNN.src.train",
        "documentation": {}
    },
    {
        "label": "plot_training_history",
        "kind": 2,
        "importPath": "Soil Classifier CNN.src.utils",
        "description": "Soil Classifier CNN.src.utils",
        "peekOfCode": "def plot_training_history(history):\n    plt.figure(figsize=(12, 4))\n    # Accuracy\n    plt.subplot(1, 2, 1)\n    plt.plot(history.history['accuracy'], label='Train Accuracy')\n    plt.plot(history.history['val_accuracy'], label='Val Accuracy')\n    plt.title('Accuracy over Epochs')\n    plt.xlabel('Epoch')\n    plt.ylabel('Accuracy')\n    plt.legend()",
        "detail": "Soil Classifier CNN.src.utils",
        "documentation": {}
    },
    {
        "label": "ROOT_DIR",
        "kind": 5,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "ROOT_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), \"..\"))\nsys.path.insert(0, ROOT_DIR)\n# Mock external dependencies\nsys.modules[\"google\"] = MagicMock()\nsys.modules[\"google.generativeai\"] = MagicMock()\nsys.modules[\"jwt\"] = MagicMock()",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "sys.modules[\"google\"]",
        "kind": 5,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "sys.modules[\"google\"] = MagicMock()\nsys.modules[\"google.generativeai\"] = MagicMock()\nsys.modules[\"jwt\"] = MagicMock()",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "sys.modules[\"google.generativeai\"]",
        "kind": 5,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "sys.modules[\"google.generativeai\"] = MagicMock()\nsys.modules[\"jwt\"] = MagicMock()",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "sys.modules[\"jwt\"]",
        "kind": 5,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "sys.modules[\"jwt\"] = MagicMock()",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "test_example",
        "kind": 2,
        "importPath": "tests.test_basic",
        "description": "tests.test_basic",
        "peekOfCode": "def test_example(): \n    assert 1 == 1",
        "detail": "tests.test_basic",
        "documentation": {}
    },
    {
        "label": "test_crop_planning_home",
        "kind": 2,
        "importPath": "tests.test_crop_planning",
        "description": "tests.test_crop_planning",
        "peekOfCode": "def test_crop_planning_home():\n    client = crop_planning_app.test_client()\n    response = client.get('/')\n    assert response.status_code == 200\n    assert b'Crop Planner AI' in response.data",
        "detail": "tests.test_crop_planning",
        "documentation": {}
    },
    {
        "label": "sanitize_input",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def sanitize_input(text):\n    \"\"\"Sanitize user input to prevent XSS and injection attacks\"\"\"\n    if not text or not isinstance(text, str):\n        return \"\"\n    # Remove HTML tags\n    text = re.sub(r'<[^>]+>', '', text)\n    # Escape special characters\n    text = text.replace('&', '&amp;')\n    text = text.replace('<', '&lt;')\n    text = text.replace('>', '&gt;')",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "validate_input",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def validate_input(data):\n    \"\"\"Validate input data structure and content\"\"\"\n    if not data:\n        return False, \"No data provided\"\n    # Check for required fields if needed\n    # Add specific validation rules here\n    return True, \"Valid input\"\n# Initialize Gemini API\nAPI_KEY = os.environ.get('GEMINI_API_KEY')\nMODEL_ID = 'gemini-2.5-flash'",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "get_firebase_config",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def get_firebase_config():\n    \"\"\"Secure endpoint to provide Firebase configuration to client\"\"\"\n    return jsonify({\n        'apiKey': os.environ.get('FIREBASE_API_KEY'),\n        'authDomain': os.environ.get('FIREBASE_AUTH_DOMAIN'),\n        'projectId': os.environ.get('FIREBASE_PROJECT_ID'),\n        'storageBucket': os.environ.get('FIREBASE_STORAGE_BUCKET'),\n        'messagingSenderId': os.environ.get('FIREBASE_MESSAGING_SENDER_ID'),\n        'appId': os.environ.get('FIREBASE_APP_ID'),\n        'measurementId': os.environ.get('FIREBASE_MEASUREMENT_ID')",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "process_loan",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def process_loan():\n    try:\n        json_data = request.get_json(force=True)\n        # Validate and sanitize input\n        is_valid, validation_message = validate_input(json_data)\n        if not is_valid:\n            return jsonify({\"status\": \"error\", \"message\": validation_message}), 400\n        # Sanitize any text fields in the JSON data\n        if isinstance(json_data, dict):\n            for key, value in json_data.items():",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "index",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def index():\n    return send_from_directory('.', 'index.html')\n@app.route('/farmer')\ndef farmer():\n    return send_from_directory('.', 'farmer.html')\n@app.route('/shopkeeper')\ndef shopkeeper():\n    return send_from_directory('.', 'shopkeeper.html')\n@app.route('/main')\ndef main():",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "farmer",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def farmer():\n    return send_from_directory('.', 'farmer.html')\n@app.route('/shopkeeper')\ndef shopkeeper():\n    return send_from_directory('.', 'shopkeeper.html')\n@app.route('/main')\ndef main():\n    return send_from_directory('.', 'main.html')\n@app.route('/about')\ndef about():",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "shopkeeper",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def shopkeeper():\n    return send_from_directory('.', 'shopkeeper.html')\n@app.route('/main')\ndef main():\n    return send_from_directory('.', 'main.html')\n@app.route('/about')\ndef about():\n    return send_from_directory('.', 'about.html')\n@app.route('/blog')\ndef blog():",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def main():\n    return send_from_directory('.', 'main.html')\n@app.route('/about')\ndef about():\n    return send_from_directory('.', 'about.html')\n@app.route('/blog')\ndef blog():\n    return send_from_directory('.', 'blog.html')\n@app.route('/contact')\ndef contact():",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "about",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def about():\n    return send_from_directory('.', 'about.html')\n@app.route('/blog')\ndef blog():\n    return send_from_directory('.', 'blog.html')\n@app.route('/contact')\ndef contact():\n    return send_from_directory('.', 'contact.html')\n@app.route('/chat')\ndef chat():",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "blog",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def blog():\n    return send_from_directory('.', 'blog.html')\n@app.route('/contact')\ndef contact():\n    return send_from_directory('.', 'contact.html')\n@app.route('/chat')\ndef chat():\n    return send_from_directory('.', 'chat.html')\n@app.route('/<path:filename>')\ndef serve_static(filename):",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "contact",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def contact():\n    return send_from_directory('.', 'contact.html')\n@app.route('/chat')\ndef chat():\n    return send_from_directory('.', 'chat.html')\n@app.route('/<path:filename>')\ndef serve_static(filename):\n    return send_from_directory('.', filename)\nif __name__ == '__main__':\n    app.run(port=5000, debug=True)",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "chat",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def chat():\n    return send_from_directory('.', 'chat.html')\n@app.route('/<path:filename>')\ndef serve_static(filename):\n    return send_from_directory('.', filename)\nif __name__ == '__main__':\n    app.run(port=5000, debug=True)",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "serve_static",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def serve_static(filename):\n    return send_from_directory('.', filename)\nif __name__ == '__main__':\n    app.run(port=5000, debug=True)",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "app = Flask(__name__, static_folder='.', static_url_path='')\nCORS(app, resources={r\"/*\": {\"origins\": \"http://127.0.0.1:5500\"}})\n# Input validation and sanitization functions\ndef sanitize_input(text):\n    \"\"\"Sanitize user input to prevent XSS and injection attacks\"\"\"\n    if not text or not isinstance(text, str):\n        return \"\"\n    # Remove HTML tags\n    text = re.sub(r'<[^>]+>', '', text)\n    # Escape special characters",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "API_KEY",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "API_KEY = os.environ.get('GEMINI_API_KEY')\nMODEL_ID = 'gemini-2.5-flash'\nif not API_KEY:\n    raise RuntimeError(\"GEMINI_API_KEY is not set in environment variables\")\n# Configure Gemini Client\nclient = genai.Client(api_key=API_KEY)\n@app.route('/api/firebase-config')\ndef get_firebase_config():\n    \"\"\"Secure endpoint to provide Firebase configuration to client\"\"\"\n    return jsonify({",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "MODEL_ID",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "MODEL_ID = 'gemini-2.5-flash'\nif not API_KEY:\n    raise RuntimeError(\"GEMINI_API_KEY is not set in environment variables\")\n# Configure Gemini Client\nclient = genai.Client(api_key=API_KEY)\n@app.route('/api/firebase-config')\ndef get_firebase_config():\n    \"\"\"Secure endpoint to provide Firebase configuration to client\"\"\"\n    return jsonify({\n        'apiKey': os.environ.get('FIREBASE_API_KEY'),",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "client = genai.Client(api_key=API_KEY)\n@app.route('/api/firebase-config')\ndef get_firebase_config():\n    \"\"\"Secure endpoint to provide Firebase configuration to client\"\"\"\n    return jsonify({\n        'apiKey': os.environ.get('FIREBASE_API_KEY'),\n        'authDomain': os.environ.get('FIREBASE_AUTH_DOMAIN'),\n        'projectId': os.environ.get('FIREBASE_PROJECT_ID'),\n        'storageBucket': os.environ.get('FIREBASE_STORAGE_BUCKET'),\n        'messagingSenderId': os.environ.get('FIREBASE_MESSAGING_SENDER_ID'),",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "token_required",
        "kind": 2,
        "importPath": "auth_utils",
        "description": "auth_utils",
        "peekOfCode": "def token_required(f):\n    @wraps(f)\n    def decorated(*args, **kwargs):\n        token = None\n        if 'Authorization' in request.headers:\n            token = request.headers['Authorization'].split(\" \")[1]\n        if not token:\n            return jsonify({'message': 'Token is missing!'}), 401\n        try:\n            data = jwt.decode(token, os.environ.get('JWT_SECRET'), algorithms=[\"HS256\"])",
        "detail": "auth_utils",
        "documentation": {}
    },
    {
        "label": "roles_required",
        "kind": 2,
        "importPath": "auth_utils",
        "description": "auth_utils",
        "peekOfCode": "def roles_required(*roles):\n    def decorator(f):\n        @wraps(f)\n        def decorated(*args, **kwargs):\n            user = getattr(request, 'user', {})\n            if user.get('role') not in roles:\n                return jsonify({'message': 'Access forbidden: insufficient permissions'}), 403\n            return f(*args, **kwargs)\n        return decorated\n    return decorator",
        "detail": "auth_utils",
        "documentation": {}
    },
    {
        "label": "PlantDiseaseNet",
        "kind": 6,
        "importPath": "model",
        "description": "model",
        "peekOfCode": "class PlantDiseaseNet(nn.Module):\n    def __init__(self, num_classes=38):  # original model had 38 classes\n        super(PlantDiseaseNet, self).__init__()\n        self.conv1 = nn.Sequential(\n            nn.Conv2d(3, 64, kernel_size=3, padding=1),\n            nn.BatchNorm2d(64),\n            nn.ReLU(inplace=True)\n        )\n        self.conv2 = nn.Sequential(\n            nn.Conv2d(64, 128, kernel_size=3, padding=1),",
        "detail": "model",
        "documentation": {}
    },
    {
        "label": "test_missing_fields",
        "kind": 2,
        "importPath": "security_test",
        "description": "security_test",
        "peekOfCode": "def test_missing_fields():\n    \"\"\"Test missing required fields\"\"\"\n    print(\"\\n=== Testing Missing Required Fields ===\")\n    # Test crop recommendation\n    try:\n        response = requests.post(f\"{BASE_URLS['crop_recommendation']}/predict\", data={})\n        if response.status_code == 400:\n            print(\"‚úì Crop Recommendation: Missing fields properly rejected\")\n        else:\n            print(\"‚úó Crop Recommendation: Missing fields not properly handled\")",
        "detail": "security_test",
        "documentation": {}
    },
    {
        "label": "test_sql_injection",
        "kind": 2,
        "importPath": "security_test",
        "description": "security_test",
        "peekOfCode": "def test_sql_injection():\n    \"\"\"Test SQL injection prevention\"\"\"\n    print(\"\\n=== Testing SQL Injection Prevention ===\")\n    for payload in SQL_INJECTION_PAYLOADS:\n        # Test crop recommendation\n        try:\n            data = {\n                'N': payload,\n                'P': '50',\n                'K': '50',",
        "detail": "security_test",
        "documentation": {}
    },
    {
        "label": "test_xss_prevention",
        "kind": 2,
        "importPath": "security_test",
        "description": "security_test",
        "peekOfCode": "def test_xss_prevention():\n    \"\"\"Test XSS prevention\"\"\"\n    print(\"\\n=== Testing XSS Prevention ===\")\n    for payload in XSS_PAYLOADS:\n        # Test forum\n        try:\n            data = {\n                'title': payload,\n                'content': 'Test content',\n                'author': 'Test Author'",
        "detail": "security_test",
        "documentation": {}
    },
    {
        "label": "test_file_upload_security",
        "kind": 2,
        "importPath": "security_test",
        "description": "security_test",
        "peekOfCode": "def test_file_upload_security():\n    \"\"\"Test file upload security\"\"\"\n    print(\"\\n=== Testing File Upload Security ===\")\n    # Test disease prediction with malicious filename\n    try:\n        files = {'file': ('../../../etc/passwd', b'fake image data', 'image/jpeg')}\n        response = requests.post(f\"{BASE_URLS['disease_prediction']}/predict\", files=files)\n        if response.status_code == 400:\n            print(\"‚úì Path traversal blocked in file upload\")\n        else:",
        "detail": "security_test",
        "documentation": {}
    },
    {
        "label": "test_numeric_validation",
        "kind": 2,
        "importPath": "security_test",
        "description": "security_test",
        "peekOfCode": "def test_numeric_validation():\n    \"\"\"Test numeric input validation\"\"\"\n    print(\"\\n=== Testing Numeric Input Validation ===\")\n    # Test invalid numeric inputs\n    invalid_inputs = [\n        {'N': 'abc', 'P': '50', 'K': '50', 'temperature': '25', 'humidity': '60', 'ph': '7', 'rainfall': '100'},\n        {'N': '50', 'P': 'xyz', 'K': '50', 'temperature': '25', 'humidity': '60', 'ph': '7', 'rainfall': '100'},\n        {'N': '50', 'P': '50', 'K': '50', 'temperature': '999', 'humidity': '60', 'ph': '7', 'rainfall': '100'},\n        {'N': '50', 'P': '50', 'K': '50', 'temperature': '25', 'humidity': '150', 'ph': '7', 'rainfall': '100'},\n    ]",
        "detail": "security_test",
        "documentation": {}
    },
    {
        "label": "test_json_validation",
        "kind": 2,
        "importPath": "security_test",
        "description": "security_test",
        "peekOfCode": "def test_json_validation():\n    \"\"\"Test JSON input validation\"\"\"\n    print(\"\\n=== Testing JSON Input Validation ===\")\n    # Test invalid JSON\n    try:\n        response = requests.post(f\"{BASE_URLS['crop_planning']}/predict\", \n                               data=\"invalid json\",\n                               headers={'Content-Type': 'application/json'})\n        if response.status_code == 400:\n            print(\"‚úì Invalid JSON properly rejected\")",
        "detail": "security_test",
        "documentation": {}
    },
    {
        "label": "test_error_handling",
        "kind": 2,
        "importPath": "security_test",
        "description": "security_test",
        "peekOfCode": "def test_error_handling():\n    \"\"\"Test error handling\"\"\"\n    print(\"\\n=== Testing Error Handling ===\")\n    # Test with extremely large inputs\n    large_input = 'A' * 10000\n    try:\n        data = {\n            'title': large_input,\n            'content': large_input,\n            'author': large_input",
        "detail": "security_test",
        "documentation": {}
    },
    {
        "label": "test_api_endpoints",
        "kind": 2,
        "importPath": "security_test",
        "description": "security_test",
        "peekOfCode": "def test_api_endpoints():\n    \"\"\"Test API endpoint availability\"\"\"\n    print(\"\\n=== Testing API Endpoint Availability ===\")\n    endpoints = [\n        (f\"{BASE_URLS['crop_prices']}/get_states\", \"GET\"),\n        (f\"{BASE_URLS['crop_prices']}/get_markets\", \"GET\"),\n        (f\"{BASE_URLS['labour_alerts']}/news\", \"GET\"),\n    ]\n    for url, method in endpoints:\n        try:",
        "detail": "security_test",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "security_test",
        "description": "security_test",
        "peekOfCode": "def main():\n    \"\"\"Run all security tests\"\"\"\n    print(\"AgriTech Security Testing Suite\")\n    print(\"=\" * 50)\n    test_missing_fields()\n    test_sql_injection()\n    test_xss_prevention()\n    test_file_upload_security()\n    test_numeric_validation()\n    test_json_validation()",
        "detail": "security_test",
        "documentation": {}
    },
    {
        "label": "BASE_URLS",
        "kind": 5,
        "importPath": "security_test",
        "description": "security_test",
        "peekOfCode": "BASE_URLS = {\n    'crop_recommendation': 'http://localhost:5501',\n    'crop_yield': 'http://localhost:5502',\n    'crop_prices': 'http://localhost:5001',\n    'forum': 'http://localhost:5000',\n    'disease_prediction': 'http://localhost:5000',\n    'crop_planning': 'http://localhost:5003',\n    'labour_alerts': 'http://localhost:5000'\n}\n# SQL Injection test payloads",
        "detail": "security_test",
        "documentation": {}
    },
    {
        "label": "SQL_INJECTION_PAYLOADS",
        "kind": 5,
        "importPath": "security_test",
        "description": "security_test",
        "peekOfCode": "SQL_INJECTION_PAYLOADS = [\n    \"admin'; DROP TABLE users; --\",\n    \"' OR '1'='1\",\n    \"admin' UNION SELECT * FROM users --\",\n    \"'; INSERT INTO users VALUES ('hacker', 'password'); --\",\n    \"' OR 1=1--\",\n    \"admin'--\",\n    \"'; DELETE FROM users; --\"\n]\n# XSS test payloads",
        "detail": "security_test",
        "documentation": {}
    },
    {
        "label": "XSS_PAYLOADS",
        "kind": 5,
        "importPath": "security_test",
        "description": "security_test",
        "peekOfCode": "XSS_PAYLOADS = [\n    \"<script>alert('XSS')</script>\",\n    \"<img src=x onerror=alert('XSS')>\",\n    \"javascript:alert('XSS')\",\n    \"<svg onload=alert('XSS')>\",\n    \"';alert('XSS');//\"\n]\n# Path traversal test payloads\nPATH_TRAVERSAL_PAYLOADS = [\n    \"../../../etc/passwd\",",
        "detail": "security_test",
        "documentation": {}
    },
    {
        "label": "PATH_TRAVERSAL_PAYLOADS",
        "kind": 5,
        "importPath": "security_test",
        "description": "security_test",
        "peekOfCode": "PATH_TRAVERSAL_PAYLOADS = [\n    \"../../../etc/passwd\",\n    \"..\\\\..\\\\..\\\\windows\\\\system32\\\\config\\\\sam\",\n    \"....//....//....//etc/passwd\",\n    \"..%2F..%2F..%2Fetc%2Fpasswd\"\n]\ndef test_missing_fields():\n    \"\"\"Test missing required fields\"\"\"\n    print(\"\\n=== Testing Missing Required Fields ===\")\n    # Test crop recommendation",
        "detail": "security_test",
        "documentation": {}
    },
    {
        "label": "validate_required_fields",
        "kind": 2,
        "importPath": "security_utils",
        "description": "security_utils",
        "peekOfCode": "def validate_required_fields(required_fields):\n    \"\"\"Decorator to validate required fields in form data\"\"\"\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            for field in required_fields:\n                if field not in request.form or not request.form[field].strip():\n                    return jsonify({'error': f'Missing required field: {field}'}), 400\n            return f(*args, **kwargs)\n        return decorated_function",
        "detail": "security_utils",
        "documentation": {}
    },
    {
        "label": "validate_json_fields",
        "kind": 2,
        "importPath": "security_utils",
        "description": "security_utils",
        "peekOfCode": "def validate_json_fields(required_fields):\n    \"\"\"Decorator to validate required fields in JSON data\"\"\"\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            if not request.is_json:\n                return jsonify({'error': 'Content-Type must be application/json'}), 400\n            json_data = request.get_json()\n            if not json_data:\n                return jsonify({'error': 'Invalid JSON data'}), 400",
        "detail": "security_utils",
        "documentation": {}
    },
    {
        "label": "sanitize_input",
        "kind": 2,
        "importPath": "security_utils",
        "description": "security_utils",
        "peekOfCode": "def sanitize_input(text, max_length=255):\n    \"\"\"Sanitize text input to prevent XSS and injection attacks\"\"\"\n    if not isinstance(text, str):\n        return \"\"\n    # Remove potentially dangerous characters\n    cleaned = re.sub(r'[<>\"\\']', '', text.strip())\n    return cleaned[:max_length]\ndef sanitize_numeric_input(value, min_val=None, max_val=None, field_name=\"\"):\n    \"\"\"Sanitize and validate numeric input\"\"\"\n    try:",
        "detail": "security_utils",
        "documentation": {}
    },
    {
        "label": "sanitize_numeric_input",
        "kind": 2,
        "importPath": "security_utils",
        "description": "security_utils",
        "peekOfCode": "def sanitize_numeric_input(value, min_val=None, max_val=None, field_name=\"\"):\n    \"\"\"Sanitize and validate numeric input\"\"\"\n    try:\n        # Remove any non-numeric characters except decimal point and minus\n        cleaned = re.sub(r'[^0-9.-]', '', str(value))\n        num_value = float(cleaned)\n        if min_val is not None and num_value < min_val:\n            raise ValueError(f\"{field_name} must be at least {min_val}\")\n        if max_val is not None and num_value > max_val:\n            raise ValueError(f\"{field_name} must be at least {max_val}\")",
        "detail": "security_utils",
        "documentation": {}
    },
    {
        "label": "validate_email_format",
        "kind": 2,
        "importPath": "security_utils",
        "description": "security_utils",
        "peekOfCode": "def validate_email_format(email):\n    \"\"\"Validate email format using email-validator library\"\"\"\n    try:\n        validate_email(email)\n        return True\n    except EmailNotValidError:\n        return False\ndef validate_phone_format(phone):\n    \"\"\"Validate phone number format\"\"\"\n    return bool(re.match(PHONE_PATTERN, phone))",
        "detail": "security_utils",
        "documentation": {}
    },
    {
        "label": "validate_phone_format",
        "kind": 2,
        "importPath": "security_utils",
        "description": "security_utils",
        "peekOfCode": "def validate_phone_format(phone):\n    \"\"\"Validate phone number format\"\"\"\n    return bool(re.match(PHONE_PATTERN, phone))\ndef validate_username_format(username):\n    \"\"\"Validate username format\"\"\"\n    return bool(re.match(USERNAME_PATTERN, username))\ndef validate_password_strength(password):\n    \"\"\"Validate password strength\"\"\"\n    if len(password) < 8:\n        return False, \"Password must be at least 8 characters long\"",
        "detail": "security_utils",
        "documentation": {}
    },
    {
        "label": "validate_username_format",
        "kind": 2,
        "importPath": "security_utils",
        "description": "security_utils",
        "peekOfCode": "def validate_username_format(username):\n    \"\"\"Validate username format\"\"\"\n    return bool(re.match(USERNAME_PATTERN, username))\ndef validate_password_strength(password):\n    \"\"\"Validate password strength\"\"\"\n    if len(password) < 8:\n        return False, \"Password must be at least 8 characters long\"\n    if not re.search(r'[a-z]', password):\n        return False, \"Password must contain at least one lowercase letter\"\n    if not re.search(r'[A-Z]', password):",
        "detail": "security_utils",
        "documentation": {}
    },
    {
        "label": "validate_password_strength",
        "kind": 2,
        "importPath": "security_utils",
        "description": "security_utils",
        "peekOfCode": "def validate_password_strength(password):\n    \"\"\"Validate password strength\"\"\"\n    if len(password) < 8:\n        return False, \"Password must be at least 8 characters long\"\n    if not re.search(r'[a-z]', password):\n        return False, \"Password must contain at least one lowercase letter\"\n    if not re.search(r'[A-Z]', password):\n        return False, \"Password must contain at least one uppercase letter\"\n    if not re.search(r'\\d', password):\n        return False, \"Password must contain at least one digit\"",
        "detail": "security_utils",
        "documentation": {}
    },
    {
        "label": "hash_password",
        "kind": 2,
        "importPath": "security_utils",
        "description": "security_utils",
        "peekOfCode": "def hash_password(password):\n    \"\"\"Hash password using bcrypt\"\"\"\n    return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')\ndef verify_password(password, hashed):\n    \"\"\"Verify password against hash\"\"\"\n    return bcrypt.checkpw(password.encode('utf-8'), hashed.encode('utf-8'))\ndef generate_secure_token():\n    \"\"\"Generate a secure random token\"\"\"\n    return str(uuid.uuid4())\ndef sanitize_filename(filename):",
        "detail": "security_utils",
        "documentation": {}
    },
    {
        "label": "verify_password",
        "kind": 2,
        "importPath": "security_utils",
        "description": "security_utils",
        "peekOfCode": "def verify_password(password, hashed):\n    \"\"\"Verify password against hash\"\"\"\n    return bcrypt.checkpw(password.encode('utf-8'), hashed.encode('utf-8'))\ndef generate_secure_token():\n    \"\"\"Generate a secure random token\"\"\"\n    return str(uuid.uuid4())\ndef sanitize_filename(filename):\n    \"\"\"Sanitize filename to prevent path traversal attacks\"\"\"\n    if not filename:\n        return \"\"",
        "detail": "security_utils",
        "documentation": {}
    },
    {
        "label": "generate_secure_token",
        "kind": 2,
        "importPath": "security_utils",
        "description": "security_utils",
        "peekOfCode": "def generate_secure_token():\n    \"\"\"Generate a secure random token\"\"\"\n    return str(uuid.uuid4())\ndef sanitize_filename(filename):\n    \"\"\"Sanitize filename to prevent path traversal attacks\"\"\"\n    if not filename:\n        return \"\"\n    # Remove any path separators and dangerous characters\n    cleaned = re.sub(r'[<>:\"/\\\\|?*]', '', filename)\n    return cleaned",
        "detail": "security_utils",
        "documentation": {}
    },
    {
        "label": "sanitize_filename",
        "kind": 2,
        "importPath": "security_utils",
        "description": "security_utils",
        "peekOfCode": "def sanitize_filename(filename):\n    \"\"\"Sanitize filename to prevent path traversal attacks\"\"\"\n    if not filename:\n        return \"\"\n    # Remove any path separators and dangerous characters\n    cleaned = re.sub(r'[<>:\"/\\\\|?*]', '', filename)\n    return cleaned\ndef validate_file_extension(filename, allowed_extensions):\n    \"\"\"Validate file extension\"\"\"\n    return '.' in filename and \\",
        "detail": "security_utils",
        "documentation": {}
    },
    {
        "label": "validate_file_extension",
        "kind": 2,
        "importPath": "security_utils",
        "description": "security_utils",
        "peekOfCode": "def validate_file_extension(filename, allowed_extensions):\n    \"\"\"Validate file extension\"\"\"\n    return '.' in filename and \\\n           filename.rsplit('.', 1)[1].lower() in allowed_extensions\ndef validate_file_size(file, max_size_bytes):\n    \"\"\"Validate file size\"\"\"\n    if file.content_length and file.content_length > max_size_bytes:\n        return False\n    return True\ndef rate_limit(max_requests, window_seconds):",
        "detail": "security_utils",
        "documentation": {}
    },
    {
        "label": "validate_file_size",
        "kind": 2,
        "importPath": "security_utils",
        "description": "security_utils",
        "peekOfCode": "def validate_file_size(file, max_size_bytes):\n    \"\"\"Validate file size\"\"\"\n    if file.content_length and file.content_length > max_size_bytes:\n        return False\n    return True\ndef rate_limit(max_requests, window_seconds):\n    \"\"\"Simple rate limiting decorator\"\"\"\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):",
        "detail": "security_utils",
        "documentation": {}
    },
    {
        "label": "rate_limit",
        "kind": 2,
        "importPath": "security_utils",
        "description": "security_utils",
        "peekOfCode": "def rate_limit(max_requests, window_seconds):\n    \"\"\"Simple rate limiting decorator\"\"\"\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            # This is a simple implementation\n            # In production, use Redis or database for rate limiting\n            client_ip = request.remote_addr\n            # Add rate limiting logic here\n            return f(*args, **kwargs)",
        "detail": "security_utils",
        "documentation": {}
    },
    {
        "label": "log_security_event",
        "kind": 2,
        "importPath": "security_utils",
        "description": "security_utils",
        "peekOfCode": "def log_security_event(event_type, details, user_ip=None):\n    \"\"\"Log security events\"\"\"\n    if user_ip is None:\n        user_ip = request.remote_addr\n    log_entry = {\n        'timestamp': str(datetime.datetime.now()),\n        'event_type': event_type,\n        'user_ip': user_ip,\n        'details': details\n    }",
        "detail": "security_utils",
        "documentation": {}
    },
    {
        "label": "sanitize_sql_input",
        "kind": 2,
        "importPath": "security_utils",
        "description": "security_utils",
        "peekOfCode": "def sanitize_sql_input(value):\n    \"\"\"Sanitize input for SQL queries (use parameterized queries instead)\"\"\"\n    if not isinstance(value, str):\n        return \"\"\n    # Remove SQL injection patterns\n    dangerous_patterns = [\n        r'(\\b(union|select|insert|update|delete|drop|create|alter|exec|execute)\\b)',\n        r'(\\b(and|or)\\b\\s+\\d+\\s*=\\s*\\d+)',\n        r'(\\b(and|or)\\b\\s+\\'\\w+\\'\\s*=\\s*\\'\\w+\\')',\n        r'(\\b(and|or)\\b\\s+\\w+\\s*=\\s*\\w+)',",
        "detail": "security_utils",
        "documentation": {}
    },
    {
        "label": "add_security_headers",
        "kind": 2,
        "importPath": "security_utils",
        "description": "security_utils",
        "peekOfCode": "def add_security_headers(response):\n    \"\"\"Add security headers to response\"\"\"\n    response.headers['X-Content-Type-Options'] = 'nosniff'\n    response.headers['X-Frame-Options'] = 'DENY'\n    response.headers['X-XSS-Protection'] = '1; mode=block'\n    response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'\n    response.headers['Content-Security-Policy'] = \"default-src 'self'\"\n    return response",
        "detail": "security_utils",
        "documentation": {}
    },
    {
        "label": "EMAIL_PATTERN",
        "kind": 5,
        "importPath": "security_utils",
        "description": "security_utils",
        "peekOfCode": "EMAIL_PATTERN = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\nPHONE_PATTERN = r'^\\+?1?\\d{9,15}$'\nUSERNAME_PATTERN = r'^[a-zA-Z0-9_]{3,20}$'\ndef validate_required_fields(required_fields):\n    \"\"\"Decorator to validate required fields in form data\"\"\"\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            for field in required_fields:\n                if field not in request.form or not request.form[field].strip():",
        "detail": "security_utils",
        "documentation": {}
    },
    {
        "label": "PHONE_PATTERN",
        "kind": 5,
        "importPath": "security_utils",
        "description": "security_utils",
        "peekOfCode": "PHONE_PATTERN = r'^\\+?1?\\d{9,15}$'\nUSERNAME_PATTERN = r'^[a-zA-Z0-9_]{3,20}$'\ndef validate_required_fields(required_fields):\n    \"\"\"Decorator to validate required fields in form data\"\"\"\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            for field in required_fields:\n                if field not in request.form or not request.form[field].strip():\n                    return jsonify({'error': f'Missing required field: {field}'}), 400",
        "detail": "security_utils",
        "documentation": {}
    },
    {
        "label": "USERNAME_PATTERN",
        "kind": 5,
        "importPath": "security_utils",
        "description": "security_utils",
        "peekOfCode": "USERNAME_PATTERN = r'^[a-zA-Z0-9_]{3,20}$'\ndef validate_required_fields(required_fields):\n    \"\"\"Decorator to validate required fields in form data\"\"\"\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            for field in required_fields:\n                if field not in request.form or not request.form[field].strip():\n                    return jsonify({'error': f'Missing required field: {field}'}), 400\n            return f(*args, **kwargs)",
        "detail": "security_utils",
        "documentation": {}
    },
    {
        "label": "url",
        "kind": 5,
        "importPath": "test",
        "description": "test",
        "peekOfCode": "url = \"http://127.0.0.1:5000/recognize\"\nfiles = {\"image\": open(\"shubhangi1.jpeg\", \"rb\")}\nr = requests.post(url, files=files)\nprint(r.json())",
        "detail": "test",
        "documentation": {}
    },
    {
        "label": "files",
        "kind": 5,
        "importPath": "test",
        "description": "test",
        "peekOfCode": "files = {\"image\": open(\"shubhangi1.jpeg\", \"rb\")}\nr = requests.post(url, files=files)\nprint(r.json())",
        "detail": "test",
        "documentation": {}
    },
    {
        "label": "r",
        "kind": 5,
        "importPath": "test",
        "description": "test",
        "peekOfCode": "r = requests.post(url, files=files)\nprint(r.json())",
        "detail": "test",
        "documentation": {}
    },
    {
        "label": "test_environment_variables",
        "kind": 2,
        "importPath": "test_security",
        "description": "test_security",
        "peekOfCode": "def test_environment_variables():\n    \"\"\"Test that environment variables are properly loaded\"\"\"\n    print(\"üîç Testing Environment Variables...\")\n    load_dotenv()\n    required_vars = [\n        'FIREBASE_API_KEY',\n        'FIREBASE_AUTH_DOMAIN', \n        'FIREBASE_PROJECT_ID',\n        'FIREBASE_STORAGE_BUCKET',\n        'FIREBASE_MESSAGING_SENDER_ID',",
        "detail": "test_security",
        "documentation": {}
    },
    {
        "label": "test_firebase_config_endpoint",
        "kind": 2,
        "importPath": "test_security",
        "description": "test_security",
        "peekOfCode": "def test_firebase_config_endpoint():\n    \"\"\"Test that the Firebase config endpoint works and doesn't expose sensitive data\"\"\"\n    print(\"\\nüîç Testing Firebase Config Endpoint...\")\n    try:\n        # Start the Flask app (you'll need to run this separately)\n        response = requests.get('http://localhost:5000/api/firebase-config', timeout=5)\n        if response.status_code == 200:\n            config = response.json()\n            # Check that all required fields are present\n            required_fields = ['apiKey', 'authDomain', 'projectId', 'storageBucket', 'messagingSenderId', 'appId']",
        "detail": "test_security",
        "documentation": {}
    },
    {
        "label": "test_client_side_exposure",
        "kind": 2,
        "importPath": "test_security",
        "description": "test_security",
        "peekOfCode": "def test_client_side_exposure():\n    \"\"\"Test that sensitive information is not exposed in client-side files\"\"\"\n    print(\"\\nüîç Testing Client-Side File Security...\")\n    # Check firebase.js for hardcoded credentials\n    try:\n        with open('firebase.js', 'r') as f:\n            content = f.read()\n        # Look for common patterns that indicate hardcoded credentials\n        suspicious_patterns = [\n            'apiKey: \"AIza',",
        "detail": "test_security",
        "documentation": {}
    },
    {
        "label": "test_gitignore",
        "kind": 2,
        "importPath": "test_security",
        "description": "test_security",
        "peekOfCode": "def test_gitignore():\n    \"\"\"Test that .env file is properly ignored\"\"\"\n    print(\"\\nüîç Testing .gitignore Configuration...\")\n    try:\n        with open('.gitignore.txt', 'r') as f:\n            content = f.read()\n        if '.env' in content:\n            print(\"‚úÖ .env file is properly listed in .gitignore\")\n            return True\n        else:",
        "detail": "test_security",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "test_security",
        "description": "test_security",
        "peekOfCode": "def main():\n    \"\"\"Run all security tests\"\"\"\n    print(\"üîí AgriTech Firebase Security Test Suite\")\n    print(\"=\" * 50)\n    tests = [\n        test_environment_variables,\n        test_firebase_config_endpoint,\n        test_client_side_exposure,\n        test_gitignore\n    ]",
        "detail": "test_security",
        "documentation": {}
    },
    {
        "label": "load_keras_model",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def load_keras_model(model_path):\n    model = load_model(model_path)\n    return model\ndef predict_image_keras(model, img_path):\n    img = image.load_img(img_path, target_size=(160, 160))  # Match your training size\n    img_array = image.img_to_array(img) / 255.0\n    img_array = np.expand_dims(img_array, axis=0)\n    predictions = model.predict(img_array)\n    predicted_index = np.argmax(predictions)\n    predicted_class = class_names[predicted_index]",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "predict_image_keras",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def predict_image_keras(model, img_path):\n    img = image.load_img(img_path, target_size=(160, 160))  # Match your training size\n    img_array = image.img_to_array(img) / 255.0\n    img_array = np.expand_dims(img_array, axis=0)\n    predictions = model.predict(img_array)\n    predicted_index = np.argmax(predictions)\n    predicted_class = class_names[predicted_index]\n    description = class_descriptions.get(predicted_class, \"No description available.\")\n    return predicted_class, description",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "class_names",
        "kind": 5,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "class_names = [\n    'Apple___Black_rot', 'Apple___healthy',\n    'Corn___Cercospora_leaf_spot', 'Corn___Common_rust',\n    'Corn___healthy', 'Grape___Black_rot', 'Grape___Esca',\n    'Grape___healthy', 'Potato___Early_blight', 'Potato___Late_blight',\n    'Potato___healthy', 'Tomato___Bacterial_spot', 'Tomato___Early_blight',\n    'Tomato___Late_blight', 'Tomato___Leaf_Mold', 'Tomato___Septoria_leaf_spot',\n    'Tomato___Spider_mites', 'Tomato___Target_Spot', 'Tomato___Yellow_Leaf_Curl_Virus',\n    'Tomato___mosaic_virus', 'Tomato___healthy'\n]",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "class_descriptions",
        "kind": 5,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "class_descriptions = {\n    'Apple___Black_rot': 'Black rot is a fungal disease. Remove affected fruit and apply fungicide.',\n    'Apple___healthy': 'The apple plant is healthy.',\n    'Corn_(maize)___Cercospora_leaf_spot Gray_leaf_spot': 'Gray leaf spot detected. Use resistant varieties and rotate crops.',\n    'Corn_(maize)___Common_rust_': 'Common rust detected. Remove infected leaves and apply fungicide.',\n    'Corn_(maize)___healthy': 'The corn plant is healthy.',\n    'Grape___Black_rot': 'Black rot detected on grapes. Remove infected parts.',\n    'Grape___Esca_(Black_Measles)': 'Esca disease detected. Prune and burn affected wood.',\n    'Grape___healthy': 'The grape plant is healthy.',\n    'Potato___Early_blight': 'Early blight detected. Use certified disease-free seeds.',",
        "detail": "utils",
        "documentation": {}
    }
]